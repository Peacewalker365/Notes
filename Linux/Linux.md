# Linux
### Installation
- [ ] VMware
### Partition Editior
	1. 主分区最多只能有4个
	2. 扩展分区只能有一个
		1. 主分区加扩展分区只能有4个
		2. 扩展分区不能写入数据 只能包含逻辑分区 逻辑分区内可以写入数据
	3. 格式化（高级格式化）又称逻辑格式化 
		1. 格式化的目的就是为了写入
		2. 就像把柜子中打入隔断（遵守某种规则划分block）
		3. 当用户读取文件的时候 调用分区表 每个文件有一个inode 从而找到对应文件
		4. 格式化就是制定和实行这一种特定的规则 并创造inode表的过程
	4. 建立硬件设备文件（自动的 但我们要看懂）
		1. 第一子目录dev下 （linux一切皆文件）
		2. IDE硬盘 _dev_hd/[a-d]
		3. SCSI_SATA_USB硬盘 _dev_sd/[a-p]
		4. 等等......
	5. 分区设备文件名
		1. _dev_hda1（IDE硬盘接口）
		2. 等等........
	6. 挂载（类似win下的分配盘符，写入挂载点）
		1. 必须分区
			1. 根分区
				- [ ] 保证有地方可以写入
			2. swap分区（其实就是虚拟内存 交换分区 一般设置内存2倍 ）
			- [ ] 当根分区不足时 有备用分区写入
			2. 推荐分区
				1. /boot（启动分区）专门保存启动时的数据 以防根分区满了 无法启动
	7. 文件系统结构
		1. /
			1. /boot
			2. /etc
				1. passwd
				2. shadow
				3. group
			3. /home
		2. 注意
			1. linux可以给任意文件层级分配分区
			2. 比如给_分配_dev_sda3 然后给_home分配dev/sda2 等等


### 远程登录管理
- [ ] 联网
	1. 桥接（利用真实网卡，人多可能有IP地址冲突）
	2. host only
	3. VMnet
- [ ] 配置网卡
	- [ ] ifconfig -ens0 192.168.118.2
		- [ ] 虚拟机的网卡一定要和host在一个网段 否则无法通信
		- [ ] 注意 这种方法只是临时生效 重启之后就会reset
- [ ] 远程连接工具
	- [ ] SecureCRT
		1. quick connect
		2. Username: root
			- [ ] 一般不推荐用root登陆，因为权限过大，容易出问题，最好用一个普通账户登录
		3. 选择带save的
		4. 进入了之后即可进入远程操控
		5. 操作谨慎，例如关机重启更改ip地址
		6. 如果有乱码 把字体改成任何一个中文字体 让他包含乱码的字符集，然后刷新
		7. 输入df 查看分区情况
	- [ ] Winscp 文件拷贝工具
		1. 登陆 文件协议 SFTP
		2. 图形化界面 带加密 简单安全
	- [ ] xshell或者xftp


### 注意事项
	1. Linux区分大小写
	2. Linux中所有文件以稳健的形式保存，包括硬件！一切皆文件
	3. Linux不靠扩展名区分文件 靠的是文件权限
		1. 注意：有一些为了使用方便的扩展名是给操作者看的 实际linux不需要
		2. 压缩包 gz bz2 配置文件conf 脚本文件sh
		3. 安全 因为病毒没有执行权限
	4. Linux所有存储设备都必须挂在之后才能使用，包括硬盘 u盘 光盘

### 服务器的维护和建议
	1. Linux各目录的作用
		1. _bin_ 存放系统命令的目录，普通用户和超级用户都可以执行。不过放在/bin下的命令在单用户模式下也可以执行
		2. _sbin_ 保存和系统环境设置相关的命令，只有超级用户才可以使用他们进行系统环境设置
		3. _usr_bin/ 存放系统命令的目录，普通用户和超级用户都可以执行，这些命令和系统启动无关，在单用户模式下无法执行
		4. _usr_sbin/ 存放根文件系统不必要的系统管理命令，例如多数服务程序，只有超级用户可以使用
		5. _boot_ 系统启动目录，保存系统启动相关的文件，如内核文件和启动引导程序（grub）文件等 强烈建议备份
		6. _dev_ 设备文件的保存位置
		7. _etc_ 配置文件的保存位置，系统内所有采用默认安装方式（rpm安装）的服务配置文件全都保存在这个目录当中，如用户账户密码，服务的启动脚本，常用服务的配置文件等 强烈建议备份
		8. _home_ 普通用户的家目录
		9. _lib_ 系统调用函数库保存位置
		10. _lost+found_ 当系统以外崩溃或机器意外关机，会产生一些文件碎片在这里，可以用作备份恢复等
		11. _media_ 挂载目录 挂在额外设备
		12. _mnt_ 挂载目录挂载NFS服务的共享目录
			1. 注意 只有空目录才能作为挂载点
			2. 挂哪都行
		13. _misc_ 挂载目录 不大用
		14. _opt_ 第三方安装的软件的保存位置，不过现在已吧还是把软件放在usr_local_中，算是业内的潜规则
		15. _proc_ 虚拟文件系统 该目录中的数据并不保存在硬盘里 在内存里 主要是内存的进程 内核 设备状态 cpu信息等等等等
		16. _sys_ 内核相关 虚拟文件系统 在内存中
		17. _root_ 超级用户的家目录
		18. _srv_ 服务数据目录 服务 应用在启动之后产生的一切数据
		19. _tmp_ 临时目录 系统存放的临时文件 最好每次开机后清空
		20. _usr_ 系统软件资源目录 注意usr不是user的缩写 而是 Unix Software Resource的缩写 系统中安装的软件大多数都保存在这里
		21. _var_ 动态数据保存位置 其实就是日志 邮件等 主要保存缓存 日志以及软件所产生的文件
	2. 服务器注意事项
		1. 远程服务器不许关机，只能重启...因为远程关了没法开
			1. 推荐使用shutdown -r now
			2. 在重启前 进行几次-sync
		2. 重启时应正确关闭服务！
		3. 不要再服务器访问高峰运行高负载命令
		4. 远程配置防火墙时不要把自己踢出服务器
			1. 防火墙是个门岗 过滤器，靠ip地址 mac号 端口 协议类型 数据包中的数据等等 并不能防病毒 不能替代放毒软件
			2. 配置不好 可能把自己踢出去了 那就凉了
				1. 有一个笨办法 设置每五分钟清空防火墙设置 知道配置结束 以防把自己踢出去进不来了
		5. 制定合理的密码规范并定期更新
		6. 合理分配权限
			1. 在够用的情况下尽可能少 就像系统启动的服务越少越好
		7. 定期备份重要数据和日志
			1. 鸡蛋不要放在同一个篮子里

## Linux常用命令
### 1. 文件处理命令
	1. 命令格式与目录处理命令ls
		1. 

### 2. 权限管理命令


### 3. 文件搜索命令


### 4. 帮助命令


### 5. 用户管理命令


### 6. 压缩解压命令


### 7. 网络命令


### 8. 关机重启命令

——————————————
分割线———此处之后换了教程
——————————————


### 开源软件
Apache — web服务器
Nginx — web服务器
MySQL — 数据库（SQLsever，Oracle贵）
Samba — Linux和windows之间的内网文件服务器
MongoDB/redis — NoSQL数据库（不遵守SQL规则 辅助MySQL）
Sphinx — 中文分词（主要是用来做搜索引擎）（见喜欢迎 —> 见喜｜欢迎）

	1. 免费
	2. 可以获得源代码
	3. 自由传播，改良，甚至销售

支撑互联网的开源技术LAMP or LNMP：Linux Apache/Nginx MySQL PHP
现在还是这样么？ 需要验证

### 二级目录
	1. usr_lib_ 应用程序调用的函数库保存位置
	2. usr_local_ 安装位置 手工安装软件保存位置，一般建议把源码包软件安装在这个位置
	3. usr_share_ 应用程序的资源文件，如帮助文档，说明文档和字体目录
	4. usr_src_ 源程序位置 我们手动下载的源码包和内核源码包可以保存在这里 不过我觉得 usr_local_src/ 好像更好 这样可以跟内核分开放
	5. usr_src_kernels/ 内核源码的保存位置
	6. _var_www_html_ rpm包安装的Apache的网页主目录
	7. _var_lib/ 程序运行时需要调用或改变的数据保存位置，如MySQL的数据保存在_var_lib_mysql_中
	8. _var_log/ 系统日志的保存位置
	9. _var_run/ 一些服务和程序运行后，它们的PID（进程ID）保存位置。是_run_目录的软链接
	10. _var_spool/ 防止队列数据的目录，就是排队等待其他程序使用的数据，比如邮件队列和打印队列
	11. _var_spool_mail_ 新收到的邮件队列保存位置，系统新收到的邮件回保存在这里
	12. _var_spool_cron_ 系统的定时任务队列保存位置，系统的计划任务会保存在这里


## 常用命令
### 命令的基本格式
1. 命令的提示符
	- [ ] [root@localhost ~] #
	- [ ] []：这是提示符的分隔符号，没有特殊含义
	- [ ] root：显示当前的登录用户
	- [ ] @：分隔符号 没有特殊含义
	- [ ] localhost：当前系统的简写主机名 完全的主机名可以通过hostname查看
	- [ ] ~：当前所在目录的最后一级目录
	- [ ] 井号是超级用户的命令提示符 $是普通用户的

2. 命令的基本格式
	- [ ] 命令  [选项] [参数]
	1. ls -l
		1. 七列数据
			1. 权限
			2. 引用计数
				1. 文件的引用计数代表该文件的硬链接个数
				2. 目录的引用计数代表该目录有多少个一级子目录（注意 有隐藏子目录）
			3. 所有者 默认为文件的创建者
			4. 所属组 默认所属组是文件建立用户的有效组，一般情况下是建立用户的所属组
			5. 文件大小 默认单位byte
				1. -h 人性化显示 自动优化大小显示
			6. 修改时间和访问时间中最紧的
			7. 文件名
**选项是用于调整命令的功能的**
	ls下支持的部分常用选项
		-a 显示所有文件
		—color=when 支持颜色输出 when的默认值是always，也可以是never或者auto
		-d 显示目录信息，而不是目录下的文件
		-h 人性化显示 按照我们的习惯显示文件大小
		-i 显示文件的i节点号
		-l 长格式显示
		等等

**参数是命令的操作对象，如果省略参数，是因为有默认参数**

### 目录操作命令
1. ls命令
2. cd命令
	1. change directory
	2. 绝对路径和相对路径
		1. 绝对路径：以根目录为参照物，从根目录开始一级一级进入目录
		2. 相对路径：以当前目录作为参照物进行目录查找
	3. cd后面参数从/开始就是绝对路径 否则就是相对目录 新手建议用绝对命令
	4. 简化用法
		1. ~代表用户的家目录
		2. -代表上次目录
		3. .代表当前目录
		4. ..代表上级目录
	5. pwd 显示当前路径
3. mkdir新建目录
	1. 除了家目录和临时目录最好不要新建目录 不安全
	2. make directories
	3. -p递归建立所需目录
		1. mkdir 123/234/345
		2. 一级一级的递归建立
4. rmdir命令
	1. remove empty directories
	2. 只能删除空目录
	3. -p递归删除
	4. 并不推荐使用 太垃圾
5. rm命令
	1. rm -r 123 递归删除（询问）
		1. 进入到最深的空文件然后一级一级上级删除
	2. rm -rf 123
		1. 删除了目录本身
		2. 非常危险！
		3. 不会进入回收站
		4. 用的时候先想清楚 否则手快过大脑就gg
		5. 建议预先安装extundelete实现linux下文件和文件夹的数据恢复！！就算这样都不一定能恢复
	3. 如果不要删除当前目录，只删除当前目录下的所有子文件
		1. rm -rf 123/*
			1. 星号为通配符 可为任意内容


### 文件操作命令
1. touch命令
	1. change file timestamps
	2. 创建空文件或或修改文件的时间戳
2. stat命令
	1. status
	2. 显示文件或文件系统的详细信息
	3. 注意linux是不记录创建时间的
	4. 注意modify和change的区别
3. cat命令
	1. concatenate
	2. 查看文件内容
	3. -n显示行号
	4. -E列出每行结尾的回车符$
	5. -v列出特殊字符
	6. -T把tab用^I显示出来
	7. -A相当于 -vET 用于列出所有隐藏符
	8. 有些文件太大了 用cat不行 cat只适合看小文件
4. more命令
	1. 分屏显示文件的命令
	2. 用来显示cat无法显示的大文件
	3. 交互
		1. 空格 向下翻页
		2. b 向上翻页
		3. 回车 向下滚动一行
		4. /字符串 搜索制定字符串
		5. q 退出
5. less命令
	1. 分行显示文件的命令
	2. 交互
		1. 上下 一行一行翻
		2. q 退出
6. head命令
	1. 显示文件头	
	2. -n 行数：显示制定行数
	3. -f：监听 不会退出文件 如果其他终端往里写数据了 会继续显示新增内容 要用ctrl+c退出
7. tail命令
	1. 显示文件尾
	2. -n 行数：显示制定行数
8. ln命令
	1. link
	2. make links between files
	3. inode
		1. inode#
		2. 时间
		3. 权限
		4. block的位置
	4. block
		1. 储存了子文件的文件名和inode
	5. 所以如果我要查d文件的inode号， 我需要找到它的上级文件的block，在查询d的inode号...层层递归。所以要从根目录开始，根目录的inode号是固定为2（1在创建内核的时候被占用了）
	6. 硬链接
		1. 源文件和硬链接会拥有相同的inode和block
		2. 引用计数增加
		3. 修改其中一个 另一个都改变
		4. 删除任意一个文件 另一个都可用
		5. 硬链接标记不清，很难确认硬链接文件位置 不建议使用
		6. 硬链接 不能链接目录 因为链一个目录 所有子文件都要链 所以linux不让瞎搞
		7. 硬链接不能跨分区 俩文件要zhi xiang同一个分区的同一个inode
		8. 两东西其实是一个文件 只是名字不同而已 就像一个教室两个门 前门进人人数改变 后面进人人数也改变 堵上一个门 一样能进教室
	7. 软链接 ln -s
		1. 软链接和源文件拥有不同的Inode和Block
		2. 引用计数不会增加
		3. 任意修改一个 另一个都改变
		4. 删除软链接，源文件不受影响，删除源文件，软链接不能使用
		5. 软链接没有实际数据，只保存源文件的Inode，不论源文件多大，软链接的大小不变
		6. 软链接的权限是最大权限lrwxrwxrwx，但是由于没有实际数据，最终访问时要参考源文件权限
		7. 软链接可以链接目录
		8. 也可以跨分区
		9. 软链接的标记特征明显 推荐使用
		10. 软链接移动要写绝对路径！！！！！否则很容易出错
		11. 其实可以理解成快捷方式 是为了照顾老手的使用习惯 因为很多升级改变了文件的位置 不好找

### 目录和文件都能操作的命令
1. rm命令
	1. -f：强制删除
	2. -i：交互删除 默认情况下就是
	3. -r：递归删除，可以删除目录
2. cp命令
	1. cp [选项] 源文件 目标文件
	2. copy
	3. -r递归复制 用于复制目录
	4. -a 相当于 -dpr 保证目标文件和源文件一模一样
	5. -d 如果源文件为软链接，则复制出的目标也为软链接
	6. -i 如果目标文件已经存在，则会询问是否覆盖
	7. -p 复制后目标文件保留源文件的属性，包括所有者 所属组 权限和时间
3. mv命令
	1. move
	2. 移动或重命名
	3. 移动目录不需要加-r
	4. mv 123 _tmp_ 把123这个文件或者目录原名移动到tmp文件下
	5. mv 123 234 把123重命名为234


### 基本权限管理
1. 权限介绍
	1. 带.的 表示受SELinux 保护的文件
	2. 共10项
		1. 文件的类型
			1. 具体类型 info ls查询
			2. 主要类型
				1. -：普通文件
				2. d：目录
				3. l：软链接
				4. 剩下的相对较常见的还有 b 块设备文件比如内存c 设备文件比如鼠标键盘 p 管道服务文件s 套接字文件 千万别动 例如可能导致要重装php或mysql
		2. 2-4 所有者权限
		3. 5-7 所属组权限
		4. 8-10 其他
		5. rwx分别代表读写执行权限
		6. 所有者权限优先于所属组权限
2. 基本权限命令
	1. chmod
	2. chmod [ugoa] [[+-=] [perm]]
		1. change file mode bits
		2. 赋予方式
			1. +
			2. -
			3. =
			4. 例子
				1. chmod u+x bcd 给bcd的所有者添加执行权限
				2. chmod g+w，o+w bcd
				3. chmod u-x，g-w，o-w bcd
				4. chmod u=rwx bcd
		3. 数字权限
			1. 4代表r
			2. 2代表w
			3. 1代表x
			4. 例子
				1. chmod 755 bcd
		4. 常用权限
			1. 644 基本权限
			2. 755 文件的执行权限和目录的基本权限
			3. 777 除了系统自带的 不允许手动赋予777 会造成安全隐患
				1. 有时候改了改了开源软件放进apache 报错权限不足，为了省事所以被改成了777，造成安全隐患
	3. chown命令
		1. change file owner and group
		2. chown [选项] 用户:所属组 文件或目录
			1. 也可用.分隔
		3. 注意：普通用户可以修改所有者是自己的文件的权限
		4. 注意：普通用户不能修改文件的所有者 哪怕是属于当前用户的文件 只有超级用户能修改所有者和所属组
		5. 测试
			1. 在root超级用户下
			2. 先添加用户 useradd user1
				1. 注意 添加用户就会自动添加进自动创建的同名组
			3. passwd user1
			4. 此处输入密码
			5. chown user1 bcd
	4. chgrp命令
		1. 修改所属组

3. 基本权限的作用（难点）
	1. 权限对文件的作用
		1. r：cat more less head tail等文件查看命令
		2. w：vim echo等修改文件数据的命令
			1. 注意：对文件有写权限 是不能删除文件的
			2. 如果想要删除文件，需要对文件的上级目录有写权限！原理是文件的原理 inode和block的内容，文件名和其对应的inode是存在于上级目录的block中的，而权限是针对inode所对应的block的，也就是说，对block的权限是储存在inode中的
		3. x：对文件来说执行权限是最高权限 也是风险最高的 代表该文件有了执行权限 是否能正确执行 不一定
	2. 权限对目录的作用
		1. r：ls
		2. w：touch rm cp mv等
			1. 对目录来说写是最高权限
		3. x：目录是不能执行的，但是如果目录拥有执行权限 对应到命令上就是可进入 可以执行cd命令
	3. 目录的可用权限
		1. 0:没有任何权限
		2. 5:基本的目录浏览和进入权限
		3. 7:完全权限
			1. 没有什么6权限 因为不能进入 拥有写权限没有意义
	4. 注意：权限对超级用户是没有意义的 不管怎么样实际都是777



### umask默认权限

1. 查看系统的umask权限
   - 默认用八进制数值显示umask的权限
     - 0022
     - 暂时我们忽略第一个数
     - 后面依次是022
     - 即
   - -S 用字母表示文件和目录的权限
2. umask权限的计算方法
   1. 新建文件的默认最大权限
      - 666
      - 执行权限对文件比较危险，不能在新建时默认赋予，必须用户手动赋予
   2. 新建目录的默认最大权限
      - 777
      - 执行权限就是进入目录，所以默认赋予
   3. 官方标准算法
      - umask需要使用二进制进行逻辑与和逻辑非联合运算得到正确的默认权限
        1. 将总权限（目录777 文件666）和umask转换为2进制
        2. 对umask取反
        3. 对两个值做与
        4. 转换为十进制即权限
      - 但我们可以这样理解
        - umask是我们希望从默认最大权限中去掉的权限
        - 如果本来有 则去掉
        - 如果本来就没有 维持原样
        - 所以 对文件来说 umask 033和022的结果都是644
   4. 注意
      - 要永久更改umask 要写入配置文件
        - /etc/profile
        - 环境变量配置文件
      - 否则都是暂时的更改



### 帮助命令

1. man命令
   1. manual
   2. man [命令]
   3. 快捷键
      1. 上下 移动一行
      2. PgUp PgDn 翻页
      3. g 第一页
      4. G/shift+g 最后一页
      5. q 退出
      6. /字符串 从当前向下搜索
      7. ？字符串 从当前向上搜索
      8. N 当搜索字符串时 使用N反向搜索
   4. 帮助级别
      1. 默认打开1级别 绝大部分命令只有1级别的
      2. 帮助级别
         1. 普通用户可以执行的系统命令和可执行文件的帮助
         2. 内核可以调用的函数和工具的帮助
         3. C语言函数的帮助
         4. 设备和特殊文件的帮助
         5. 配置文件的帮助
         6. 游戏的帮助
         7. 杂项的帮助
         8. 超级用户可执行的系统命令的帮助
         9. 内核的帮助
      3. man -f 命令 或者 whatis 命令
         - 查看命令拥有哪个级别的帮助
         - 小tip：新系统或者刚恢复快照 可能用whatis报错 可用makewhatis 解决
      4. man -k 命令 或者 apropos 命令
         - 查看命令相关的所有帮助
         - 只要包含命令的字符串都会被找到   不常用
2. info命令
   1. info命令比man更详细，是一套完整的资料
   2. 如果man找不到有用的信息，在用info
3. help命令
   1. 只能获取shell内置命令的帮助
   2. 作用很有限 一般不用
4. --help选项
   1. 绝大多数命令都可以使用--help选项来查看帮助
   2. 输出的帮助信息基本是man的简化版
   3. 例如 ls --help



### 搜索命令

1. whereis命令

   1. 搜索命令的命令 不能搜索文件
   2. 搜索位置和帮助文档的位置

2. which命令

   1. 搜索命令的命令 不能搜索文件
   2. 搜索位置和灵命的别名

3. locate命令

   1. 按照文件名搜索普通文件的命令
   2. 优点：按照数据库搜索，速度快，消耗资源少，数据库位置/var/lib/mlocate/mlocate.db
   3. 缺点；只能按照文件名来搜索文件，不能执行更复杂的搜索
   4. 注意：搜索前先更新库 updatedb 否则刚产生的文件夹可能找不着
   5. 注意：配置文件里会排除一些文件和目录 例如tmp下的文件是搜不到的
   6. 常用

4. find命令

   1. 按照文件名搜索

      1. -name

         - find [路径] -name [文件名]

         - 严格区分大小写

      2. -iname

         - 不区分大小写

      3. -inum

         - 按照inode去搜索文件

   2. 按照文件大小搜索

      1. -size
         - find . -size -15
           - 默认单位b 512字节
           - c for byte
           - w for 2字节
           - k for KB
           - M for MB
           - G for GB
           - 大小之前- 代表小于

   3. 按照修改时间搜索

      1. -atime 访问时间
      2. -mtime 修改时间
      3. -ctime 状态修改时间
      4. 前三个时间单位为天
      5. -amin -mmin -cmin 以分钟为单位
      6. 格式：find . -atime +5
         - -5 五天内
         - 5 五到六天前的那24小时
         - +5 六天之前

   4. 按照权限来搜索

      1. -perm
         - 支持+—
         - +444 搜索包含444种任意一个组的权限的文件 三个数任意一个大于等于4
         - -444 搜索全部包含权限模式的文件 三个数全部大于等于4
         - 444 搜索搞好等于权限模式的文件

   5. 按照所有者和所属组搜索

      1. -uid
      2. -gid
      3. -user
      4. -group
      5. -nouser 查找没有所有者文件 即外来文件 如光盘和U盘等 否则一般是垃圾文件 常用来搜索垃圾文件

   6. 按照文件类型搜索

      1. find . -type d abc 查找目录
      2. -type f 普通文件
      3. -type l 软连接文件

   7. 逻辑运算符

      - find 搜索路径 选项 搜索内容

      1. -a 与
         - find . -size +2k -a -type f
      2. -o 或
      3. -not 或者!   非

   8. 其他选项

      1. -exec

         - find 搜索路径 选项 搜索内容 -exec 命令2 {} \;

         - 把find命令的结果交给由-exec调用的命令2来处理 {}就代表find命令的查找结果
         - find . -size +2k -a -type f -exec ls -lh {} \;
         - 注意命令2不支持别名

      2. -ok

         - 区别是每执行一次命令2 就询问一次
         - -exec就直接处理了
         - -ok 比-exec适合执行删除

5. grep命令

   1. 用于在文件中搜索符合条件的字符串
   2. 如果需要模糊搜索，使用正则表达式进行匹配
   3. 选项
      1. -i 忽略大小写
      2. -n 输出其在原始文件里的行号
      3. -v 取反
      4. --color=auto 搜索的字符串红色高亮

### 通配符

完全匹配

?匹配1个任意字符

*匹配任意个数任意字符 可以为0个字符

[] 匹配其中任何一个字符

[-] 表示范围

[^] 表示取反



### 正则表达式

用于包含匹配

? 匹配0或1个前一个字符 属于扩展正则符 需要egrep来识别

\* 匹配任意个数前一个字符

* "a*" meaningless since it can be any string

^ 限位符 匹配行首

$限位符 匹配行尾

正则一般用来粗过滤 因为文本处理快 占用资源小 支持访问量大 所以一般先用正则粗过滤 然后用程序过滤

#### 对比find和grep

1. find默认完全匹配 grep默认包含匹配
2. grep搜索的是字符串



### 管道符

1. 命令1 | 命令2
2. 命令1的争取输出作为命令2的操作对象
3. 为啥有了-exec还要管道符呢
   1. ｜是文本流操作
   2. find不支持文本流操作 所以不支持管道符
4. 例子
   1. ll /etc/ ｜ more
   2. ll /etc/ ｜ grep
      - 注意此处不能用find 因为grep才是搜索字符串的 更别说find不支持文本流
   3. netstat -tuln 查询系统中所有开启的端口
      1. netstat -tuln ｜ grep 80
         - 注意这个是包含匹配 是包含80的端口
   4. netstat -an 所有的端口号
      1. enstat -an | grep ESTABLISED | wc -l
      2. 统计正在连接的数量



### 命令的别名

1. alias 别名=' 命令'
2. alias grep=' grep --color=auto'
3. alias ser =' service network restart'
4. 注意！！ 别名的优先级比系统命令高，不要和系统命令重叠
5. 默认是临时的改变 永久更改需要写入配置文件~/bashrc
6. 注意！！**放在/etc/下的配置文件 对所有用户生效 放在家目录~/下的只对该用户生效*



### 常用快捷键

1. ctrl+a 光标移动到行首
2. ctrl+e 光标移动到行尾
3. Tab 命令或文件补全
4. ctrl+c 强制终止当前的命令
5. ctrl+l 相当于clear
6. ctrl+u 删除或剪切光标到行首的命令
7. ctrl+y 粘贴ctrl+u的内容



### 压缩和解压缩命令

- 系统无所谓扩展名 这是个管理员看的 因为不同格式的压缩命令不同

1. .zip
   1. windows下的压缩格式
   2. zip [选项] 压缩文件名 源文件名
      1. -r 压缩目录
      2. -d 解压缩
   3. unzip 文件名
      1. -d 制定解压缩位置
   4. 不常用
   
2. .gz
   - .gz较古老 压缩比低 占用资源少
   - bz2压缩比高 消耗资源多
   1. gzip
   2. gzip [选项] 源文件
      1. -c 将压缩数据输出到标准输出中，可以用于保留原文件
         - gzip -c abc >> abc.gz
         - 非常规操作
      2. -d 解压缩
      3. -r 压缩目录
         1. **不会打包**
            1. gzip -r abc
            2. abc目录下的每一个文件都压缩了 但是目录本身没有变
   3. gunzip 文件名
      - 解压缩

3. bz2

   1. bzip2
   2. bzip2 [选项] 源文件名
      1. -k 保留原文件
      2. -d 解压缩
      3. -v显示解压详细信息
   3. bunzip2 文件名
   4. **不能压缩目录**

4. .tar格式   **打包不会压缩**

   1. tar [选项] [-f 压缩包名] 源文件或目录
      1. -c 打包
      2. -f 制定压缩包文件名 压缩包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名
      3. -v 显示打包文件过程
   2. tar -cvf anaconda-ks.cfg.tar anaconda-ks.cfg
   3. -x 解打包
      - 一般-xvf

5. **tar.gz 和 tar.bz2格式**

   1. tar [选项] 压缩包 源文件或目录
      1. -z 压缩和解压缩.tar.gz格式
      2. -j 压缩和解压缩.tar.bz2格式
   2. 所以 压缩 tar -zcvf 或者tar -jcvf
   3. 解压 tar-zxvf 或者tar -jxvf
   4. 只查看一下不解压 把c换成t就行了
   5. 解压缩到指定位置
      1. 解压缩的文件名后面 -C 解压路径
      2. tar -zxvf you.tar.gz -C abc/bcd
   6. 解压特定文件到指定位置
      1. tar -ztvf yui.tar.gz先看看里面有啥
      2. tar -zxvf yui.tar.gz -C /tmp test/cde
      3. 再解压其中的cde文件到/tmp中



### 关机和重启命令

1. sync数据同步
   1. flush file system buffers
   2. 刷新文件系统缓存
2. shutdown命令
   1. bring the system down
   2. -c 取消已经执行的shutdown命令
   3. -h 关机
   4. -r 重启
      - shutdown -r now
      - shutdown -r 05:30 最好不要在固定时间重启 比较危险 千分之几的几率存储设备出问题 不推荐让计算机自己执行 一般要有人看着
   5. 最安全的关机命令 会先保存各种东西再关
3. reboot命令
   1. 现在的系统中reboot也是安全的 而且不需要加入过多的选项
4. halt和poweroff
   1. 不推荐 不保存
5. init命令
   1. init是修改Linux运行级别的命令，也可以用于关机和重启，不建议使用



### 常用网络命令

1. 配置IP地址
   1. setup工具 （redhat系列专有）
   2. vi /etc/sysconfig/network-scripts/ifcfg-eth0    手工修改配置文件 主流方法
2. 重启网络服务
   - service network restart
3. 如果是虚拟机 需要侨界到有线网卡，并重启网络服务
4. 复制镜像有可能需要UUID（唯一识别符）
   1. 网卡配置文件里有
   2. 快照和当前系统UUID一样 或者 由于克隆虚拟机导致的UUID冲突
   3. vi /etc/sysconfig/network-scripts/ifcfg-eth0 删除MAC地址行
   4. rm -rf /etc/udev/rules.d/70-persistent-net.rules    删除MAC地址和UUID绑定文件
   5. reboot    重启Linux
   6. 此时UUID会重新计算 不可能像再相同

2. ifconfig命令
3. ping命令
   1. ping [选项] IP
      1. -c 指定ping的次数
      2. -b 探测整个网段 用于检测整个网段有多少台电脑
      3. -s 指定探测包的大小 感觉没啥用
4. netstat命令
   1. -a 列出所有网络状态 包括Socket程序
   2. -c 秒数：指定每隔几秒刷新一次网络状态
   3. -n：使用IP地址和端口号显示，不使用域名与服务名
   4. -t 显示使用TCP协议端口的连接状况
   5. -u 显示使用UDP.......
   6. -l 仅显示监听状态的连接
   7. -p 查看PID 看哪个程序占用了端口
      - netstat -tulnp
   8. -rn 可以查看网关
5. write命令
   1. 向其他用户发送信息
   2. w 看看谁在登陆中
   3. 登陆终端
      1. 本地字符终端tty1-6 使用快捷键alt+F1-6
      2. 本地图形终端 tty7 ctrl+alt+F7按住3秒 需要安装图形界面才有
      3. 远程终端 pts/0-255
   4. write 用户名 终端名
   5. 开始写sfsdfdg
   6. ctrl+d发送信息
6. wall命令
   1. 给所有人发送信息
7. mail命令
   1. 发邮件 mail 用户名
      1. mail 用户名
      2. 输入内容
   2. 查看mail
      1. 直接输入mail命令
      2. 输入标题号查看
      3. h键看标题
   3. 发送文件内容 常用
      1. mail -s “the subject” 用户名 /root/anaconda-ks.cfg
      2. -s "fsdfwe" 是邮件标题



### 系统痕迹命令

- 系统中的一些重要的痕迹日志文件，如/var/log/wtmp, /var/run/utmp, /var/log/btmp, /var/log/lastlog等日志文件，只能通过对应的命令查看，通过vim打开是乱码

1. w命令
   1. /var/run/utmp
   2. 第一行 系统时间 开机了多少时间 几个用户登陆中 系统前1分钟 5分钟 15分钟的平均负载
      1. 1分钟的负载超过核数 一般来说就是负载比较高了
      2. CPU和内存 70/90原则 cpu不要超过70%内存不要超过90%
   3. 第二行以后 用户名 终端名 IP 登陆时间 用户闲置时间 所有进程占用CPU时间 当前进程占用CPU时间 在干啥（-bash就是啥也没干 在等待）
2. who命令
   1. 也是看的w查看的日志
   2. 区别就是显示更简单
3. last命令
   1. 查看系统所有登陆过的用户信息
   2. /var/log/wtmp
4. lastlog命令
   1. 查看所有用户最后一次登陆的时间（包括系统用户）
   2. /var/log/lastlog
5. lastb命令
   1. 查看错误的登陆信息
   2. 比如密码输错了
   3. /var/log/btmp



### 挂载命令

1. mount命令基本格式

   - mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点

   1. linux所有储存设备都必须挂载
   2. 把设备名和一个空目录挂载
   3. mount
      1. 显示现在系统中挂载的设备
      2. 注意swap不用挂载 直接供内核访问
   4. mount -a 自动挂载 移动存储设备最好不要自动挂载 要是没插 会崩溃
      1. 命令会依据配置文件 /etc/fstab的内容 自动挂载
      2. 如果配置文件出错要修复 必须服务器现场
      3. 但现在来说 这个配置文件已经没有这么脆弱了 但是还是要非常注意
   5. -o里面都不建议修改 尤其是执行权限 容易有大问题 如果root所在分区不可执行 系统就崩溃了 无法启动

2. 光盘挂载

   1. mkdir /mnt/cdrom
   2. centOS6以后光盘设备名是/dev/sr0 以此类推
   3. 同时dev/cdrom是其软链接
   4. mount /dev/sr0 /mnt/cdrom
   5. 然后去挂载点访问光盘的内容
   6. 注意 一定记得卸载
      1. umount /dev/sr0
      2. 或者umount /mnt/cdrom都可以

3. U盘挂载

   1. fdisk -l   U盘跟硬盘共享设备名 所以不固定 要先查询
   2. 假设我们查到usb设备名为sdb1 格式为FAT32
   3. mount -t vfat /dev/sdb4 /mnt/usd/
   4. cd /mnt/usb/
   5. ls
   6. 发现中文都不能正常显示
      1. 要显示中文 首先要安装中文编码
      2. 终端要支持
      3. 注意本地终端不支持中文
      4. 但是远程终端是可以的
      5. 所以挂载时要手工指定中文编码
      6. mount -t vfat -o iocharset-utf8 /dev/sdb1 /mnt/usb/
      7. cd /mnt/usb/
      8. ls
      9. 这时应该可以了
   7. 用完卸载

4. 挂载NTFS分区 （默认不识别 就算挂载了 最多只读）

   1. Linux的驱动加载顺序
      1. 驱动直接放入内核中，这种主要是系统加载必须的驱动，数量较少
      2. 驱动以模块的形式放入硬盘，大多数驱动都用这种方式，保存位置是/lib/modules/kernel/      驱动模块是以.ko结尾的
      3. 驱动可以被Linux识别，但是系统认为这种驱动一般不常用，默认不加载，如果加载需要重新编译内核，而NTFS文件系统的驱动就属于这种情况
      4. 硬件不能被Linux内核识别，需要手工安装驱动。当然前提是厂商提供了该硬件针对Linux的驱动，否则就要自己开发驱动了（笑）
   2. 使用NTFS-3G安装NTFS文件系统模块
      1. 后面学了安装再说



## vim编辑器

- vim是全屏幕纯文本编辑器，是vi编辑器的增强版

### vim基本使用

1. vim的工作模式
   1. 命令模式
      1. 用快捷键操作 无法写入
      2. ZZ 保存退出
      3. 插入命令
         1. a 追加 在光标坐在字符后插入
         2. i 插入 在光标坐在字符前插入
         3. A 光标所在行尾插入
         4. I 光标所在行首插入
         5. o 光标下插入新行
         6. O 光标上插入新行
   2. 输入模式
      1. 输入：进入编辑模式
   3. 编辑模式（末行模式）
      1. ：w 保存不退出
      2. ：w 新文件名   相当于另存为
      3. ：q不保存退出
      4. ：wq 保存退出
      5. ：！强制
      6. ：q！强制不保存退出，用于修改文件后不保存数据退出
      7. ：wq！强制保存退出，当**文件的所有者或者root用户**，对文件没有写入权限时候（比如000），强制写入数据使用

### 命令模式操作

1. 光标移动
   1. hjkl 左下上右
   2. 文件首尾
      1. gg 移动带文件头
      2. G 移动到文件尾
   3. 行首行尾
      1. ^ 移动到行首
      2. & 移动到行尾
   4. 移动到指定行
      1. :n 其中n是数字
2. 删除和剪切
   1. x 删除单个字母
   2. nx 删除n个字母
   3. dd 删除剪切单行
   4. ndd 删除剪切多行
   5. ：n1,n2d 删除指定范围 例如:3,5d
   6. p 粘贴到光标后
   7. P 粘贴到光标前
   8. dG从光标所在行删除到文件尾
   9. yy 复制单行
   10. nyy复制多行
   11. u 撤销
   12. ctrl+r 反撤销
   13. r 替换光标所在处字符
   14. R 从光标所在处开始替换字符，按ESC结束

### 末行模式

1. vim 配置文件 ~/.vimrc
   1. ：set all 进行查看
   2. ：set nu   ：set nonu   显示与取消行号
   3. ：syntax on   ：syntax off   是否根据语法显示相关颜色的帮助
   4. ：set hlsearch  ：set nohlsearch   是否将查找的字符串高亮显示
   5. ：set ruler   ：set noruler   是否显示右下角状态栏
   6. ：set showmode   ：set noshowmode   是否左下角显示模式状态栏
   7. ：set list   ：set nolist  是否显示隐藏字符   tab是^I 回车是$

### 查找

- /查找内容   从光标所在行向下查找
- ?查找内容   从光标坐在行向上搜索
- n 下一个
- N 上一个

### 替换

- ：1，10s/old/new/g   替换1到10行所有old为new
  - s代表替换
  - g代表替换所有
- ：%s/old/new/g   替换整个文件的old为new
  - %是个变量 这里代表整篇文档
- ：1，10s/^ /#/g 注释1到10行
- ：1，10/^#//g 取消注释
- ：1，10/^\/\//g 1到10行 行首加入//
  1. 或者 按esc进入命令模式
  2. ctrl+v
  3. 上下移动选取
  4. shift+i and type
  5. esc

### vim使用技巧

1. 在vim中导入其他文件内容或命令结果
   1. ：r 文件名
      * 把文件内容导入光标位置
2. 在vim中执行系统命令
   1. ：！命令
      - 暂时跳出vim执行一次系统命令
3. 导入命令结果
   1. ：r !命令
4. 设定快捷键
   1. ：map 快捷键 快捷键执行的命令
   2. ：map ^P I#\<ESC\>   按ctrl+p在行首加入注释
   3. ：map ^B ^x    按ctrl+b 删除行首第一个字母
      - 注意 ^ 使用 ctrl+v输入的 普通的^并不起作用
   4. 要永久生效 写入~/.vimrc
5. 字符替换
   1. ：ab 原字符 替换为字符
      - 在vim编辑中 有时需要频繁输入长字符串 例如邮箱 我们可以用另一个字符串代替 每次输入源字符 自动变
6. 多文件打开
   1. vim -o abc bcd
      - 上下分屏打开两个文件
      - ctrl+w 再按方向键 在文件之间跳转
      - 如果要左右分屏 则-O



## 软件包安装

### 软件包分类

- 源码包
- 二进制包

1. 源码包
   1. 开源 可以自己动手改
   2. 自由选择所需功能
   3. 软件是便衣安装，更加舍和自己的系统，稳定，效率高
   4. 卸载方便
   5. 安装过程步骤较多，尤其安装较大软件合集时，容易出现拼写错误
   6. 编译时间长，比二进制安装时间长
   7. 因为是编译安装，安装过程中一旦报错新手很难解决
2. 二进制包
   1. DPKG包 一般叫Deb包 因为由Debian开发
   2. PRM包 由Red Hat开发
   3. 简单 命令实现安装升级查询卸载
   4. 功能选择不灵活
   5. 依赖性
   6. 看不到源代码
3. 软件包选择建议
   1. 源码包：如果服务是给大量客户端提供访问的，建议使用源码包，源码包效率更高
   2. RPM包：如果程序是给少量用户访问，或者本地使用的，建议RPM包，因为RPM管理

