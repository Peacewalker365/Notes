# Linux
### Installation
- VMware

### Partition Editior
1. 主分区最多只能有4个
2. 扩展分区只能有一个
	1. 主分区加扩展分区只能有4个
	2. 扩展分区不能写入数据 只能包含逻辑分区 逻辑分区内可以写入数据
3. 格式化（高级格式化）又称逻辑格式化 
	1. 格式化的目的就是为了写入
	2. 就像把柜子中打入隔断（遵守某种规则划分block）
	3. 当用户读取文件的时候 调用分区表 每个文件有一个inode 从而找到对应文件
	4. 格式化就是制定和实行这一种特定的规则 并创造inode表的过程
4. 建立硬件设备文件（自动的 但我们要看懂）
	1. 第一子目录dev下 （linux一切皆文件）
	2. IDE硬盘 _dev_hd/[a-d]
	3. SCSI_SATA_USB硬盘 _dev_sd/[a-p]
	4. 等等......
5. 分区设备文件名
	1. _dev_hda1（IDE硬盘接口）
	2. 等等........
6. 挂载（类似win下的分配盘符，写入挂载点）
  1. 必须分区
        1. 根分区
      - 保证有地方可以写入
        2. swap分区（其实就是虚拟内存 交换分区 一般设置内存2倍 ）
       - 当根分区不足时 有备用分区写入
        3. 推荐分区
      1. /boot（启动分区）专门保存启动时的数据 以防根分区满了 无法启动
7. 文件系统结构
	1. /
		1. /boot
		2. /etc
			1. passwd
			2. shadow
			3. group
		3. /home
	2. 注意
		1. linux可以给任意文件层级分配分区
		2. 比如给_分配_dev_sda3 然后给_home分配dev/sda2 等等


### 远程登录管理
- 联网

1. 桥接（利用真实网卡，人多可能有IP地址冲突）
2. host only
3. VMnet

- 配置网卡
  - ifconfig -ens0 192.168.118.2

  - 虚拟机的网卡一定要和host在一个网段 否则无法通信
  - 注意 这种方法只是临时生效 重启之后就会reset

- 远程连接工具

  - SecureCRT

    1. quick connect

    2. Username: root
       1. 一般不推荐用root登陆，因为权限过大，容易出问题，最好用一个普通账户登录

- 选择带save的

- 进入了之后即可进入远程操控

- 操作谨慎，例如关机重启更改ip地址

- 如果有乱码 把字体改成任何一个中文字体 让他包含乱码的字符集，然后刷新

- 输入df 查看分区情况

- Winscp 文件拷贝工具

  1. 登陆 文件协议 SFTP

  2. 图形化界面 带加密 简单安全

- xshell或者xftp


### 注意事项
1. Linux区分大小写
2. Linux中所有文件以稳健的形式保存，包括硬件！一切皆文件
3. Linux不靠扩展名区分文件 靠的是文件权限
	1. 注意：有一些为了使用方便的扩展名是给操作者看的 实际linux不需要
	2. 压缩包 gz bz2 配置文件conf 脚本文件sh
	3. 安全 因为病毒没有执行权限
	4. Linux所有存储设备都必须挂在之后才能使用，包括硬盘 u盘 光盘

### 服务器的维护和建议
2. 服务器注意事项
	1. 远程服务器不许关机，只能重启...因为远程关了没法开
		1. 推荐使用shutdown -r now
		2. 在重启前 进行几次-sync
	2. 重启时应正确关闭服务！
	3. 不要再服务器访问高峰运行高负载命令
	4. 远程配置防火墙时不要把自己踢出服务器
		1. 防火墙是个门岗 过滤器，靠ip地址 mac号 端口 协议类型 数据包中的数据等等 并不能防病毒 不能替代放毒软件
		2. 配置不好 可能把自己踢出去了 那就凉了
			1. 有一个笨办法 设置每五分钟清空防火墙设置 知道配置结束 以防把自己踢出去进不来了
	5. 制定合理的密码规范并定期更新
	6. 合理分配权限
		1. 在够用的情况下尽可能少 就像系统启动的服务越少越好
	7. 定期备份重要数据和日志
		1. 鸡蛋不要放在同一个篮子里




### 开源软件
Apache — web服务器
Nginx — web服务器
MySQL — 数据库（SQLsever，Oracle贵）
Samba — Linux和windows之间的内网文件服务器
MongoDB/redis — NoSQL数据库（不遵守SQL规则 辅助MySQL）
Sphinx — 中文分词（主要是用来做搜索引擎）（见喜欢迎 —> 见喜｜欢迎）

	1. 免费
	2. 可以获得源代码
	3. 自由传播，改良，甚至销售

支撑互联网的开源技术LAMP or LNMP：Linux Apache/Nginx MySQL PHP
现在还是这样么？ 需要验证

### 一级目录

  1. _bin_ 存放系统命令的目录，普通用户和超级用户都可以执行。不过放在/bin下的命令在单用户模式下也可以执行

  2. _sbin_ 保存和系统环境设置相关的命令，只有超级用户才可以使用他们进行系统环境设置

  3. _usr_bin/ 存放系统命令的目录，普通用户和超级用户都可以执行，这些命令和系统启动无关，在单用户模式下无法执行

  4. _usr_sbin/ 存放根文件系统不必要的系统管理命令，例如多数服务程序，只有超级用户可以使用

  5. _boot_ 系统启动目录，保存系统启动相关的文件，如内核文件和启动引导程序（grub）文件等 强烈建议备份

  6. _dev_ 设备文件的保存位置

  7. _etc_ 配置文件的保存位置，系统内所有采用默认安装方式（rpm安装）的服务配置文件全都保存在这个目录当中，如用户账户密码，服务的启动脚本，常用服务的配置文件等 强烈建议备份

  8. _home_ 普通用户的家目录

  9. _lib_ 系统调用函数库保存位置

  10. _lost+found_ 当系统以外崩溃或机器意外关机，会产生一些文件碎片在这里，可以用作备份恢复等

  11. _media_ 挂载目录 挂在额外设备

  12. _mnt_ 挂载目录挂载NFS服务的共享目录

      1. 注意 只有空目录才能作为挂载点

      2. 挂哪都行

  13. _misc_ 挂载目录 不大用

  14. _opt_ 第三方安装的软件的保存位置，不过现在已吧还是把软件放在usr_local_中，算是业内的潜规则

  15. _proc_ 虚拟文件系统 该目录中的数据并不保存在硬盘里 在内存里 主要是内存的进程 内核 设备状态 cpu信息等等等等

  16. _sys_ 内核相关 虚拟文件系统 在内存中

  17. _root_ 超级用户的家目录

  18. _srv_ 服务数据目录 服务 应用在启动之后产生的一切数据

  19. _tmp_ 临时目录 系统存放的临时文件 最好每次开机后清空

  20. _usr_ 系统软件资源目录 注意usr不是user的缩写 而是 Unix Software Resource的缩写 系统中安装的软件大多数都保存在这里

  21. _var_ 动态数据保存位置 其实就是日志 邮件等 主要保存缓存 日志以及软件所产生的文件



### 二级目录
1. usr_lib_ 应用程序调用的函数库保存位置
2. usr_local_ 安装位置 手工安装软件保存位置，一般建议把源码包软件安装在这个位置
3. usr_share_ 应用程序的资源文件，如帮助文档，说明文档和字体目录
4. usr_src_ 源程序位置 我们手动下载的源码包和内核源码包可以保存在这里 不过我觉得 usr_local_src/ 好像更好 这样可以跟内核分开放
5. usr_src_kernels/ 内核源码的保存位置
6. _var_www_html_ rpm包安装的Apache的网页主目录
7. _var_lib/ 程序运行时需要调用或改变的数据保存位置，如MySQL的数据保存在_var_lib_mysql_中
8. _var_log/ 系统日志的保存位置
9. _var_run/ 一些服务和程序运行后，它们的PID（进程ID）保存位置。是_run_目录的软链接
10. _var_spool/ 防止队列数据的目录，就是排队等待其他程序使用的数据，比如邮件队列和打印队列
11. _var_spool_mail_ 新收到的邮件队列保存位置，系统新收到的邮件回保存在这里
12. _var_spool_cron_ 系统的定时任务队列保存位置，系统的计划任务会保存在这里


## 常用命令
### 命令的基本格式
1. 命令的提示符
  - [root@localhost ~] #

  - []：这是提示符的分隔符号，没有特殊含义

  - root：显示当前的登录用户

  - @：分隔符号 没有特殊含义

  - localhost：当前系统的简写主机名 完全的主机名可以通过hostname查看

  - ~：当前所在目录的最后一级目录

  - 井号是超级用户的命令提示符 $是普通用户的

2. 命令的基本格式
  - 命令  [选项] [参数]

  1. ls -l
  	1. 七列数据
  		1. 权限
  		2. 引用计数
  			1. 文件的引用计数代表该文件的硬链接个数
  			2. 目录的引用计数代表该目录有多少个一级子目录（注意 有隐藏子目录）
  		3. 所有者 默认为文件的创建者
  		4. 所属组 默认所属组是文件建立用户的有效组，一般情况下是建立用户的所属组
  		5. 文件大小 默认单位byte
  			1. -h 人性化显示 自动优化大小显示
  		6. 修改时间和访问时间中最紧的
  		7. 文件名
  **选项是用于调整命令的功能的**
  ls下支持的部分常用选项
  	-a 显示所有文件
  	—color=when 支持颜色输出 when的默认值是always，也可以是never或者auto
  	-d 显示目录信息，而不是目录下的文件
  	-h 人性化显示 按照我们的习惯显示文件大小
  	-i 显示文件的i节点号
  	-l 长格式显示
  	等等

**参数是命令的操作对象，如果省略参数，是因为有默认参数**

### 目录操作命令
1. ls命令
2. cd命令
	1. change directory
	2. 绝对路径和相对路径
		1. 绝对路径：以根目录为参照物，从根目录开始一级一级进入目录
		2. 相对路径：以当前目录作为参照物进行目录查找
	3. cd后面参数从/开始就是绝对路径 否则就是相对目录 新手建议用绝对命令
	4. 简化用法
		1. ~代表用户的家目录
		2. -代表上次目录
		3. .代表当前目录
		4. ..代表上级目录
	5. pwd 显示当前路径
3. mkdir新建目录
	1. 除了家目录和临时目录最好不要新建目录 不安全
	2. make directories
	3. -p递归建立所需目录
		1. mkdir 123/234/345
		2. 一级一级的递归建立
4. rmdir命令
	1. remove empty directories
	2. 只能删除空目录
	3. -p递归删除
	4. 并不推荐使用 太垃圾
5. rm命令
	1. rm -r 123 递归删除（询问）
		1. 进入到最深的空文件然后一级一级上级删除
	2. rm -rf 123
		1. 删除了目录本身
		2. 非常危险！
		3. 不会进入回收站
		4. 用的时候先想清楚 否则手快过大脑就gg
		5. 建议预先安装extundelete实现linux下文件和文件夹的数据恢复！！就算这样都不一定能恢复
	3. 如果不要删除当前目录，只删除当前目录下的所有子文件
		1. rm -rf 123/*
			1. 星号为通配符 可为任意内容


### 文件操作命令
1. touch命令
	1. change file timestamps
	2. 创建空文件或或修改文件的时间戳
2. stat命令
	1. status
	2. 显示文件或文件系统的详细信息
	3. 注意linux是不记录创建时间的
	4. 注意modify和change的区别
3. cat命令
	1. concatenate
	2. 查看文件内容
	3. -n显示行号
	4. -E列出每行结尾的回车符$
	5. -v列出特殊字符
	6. -T把tab用^I显示出来
	7. -A相当于 -vET 用于列出所有隐藏符
	8. 有些文件太大了 用cat不行 cat只适合看小文件
4. more命令
	1. 分屏显示文件的命令
	2. 用来显示cat无法显示的大文件
	3. 交互
		1. 空格 向下翻页
		2. b 向上翻页
		3. 回车 向下滚动一行
		4. /字符串 搜索制定字符串
		5. q 退出
5. less命令
	1. 分行显示文件的命令
	2. 交互
		1. 上下 一行一行翻
		2. q 退出
6. head命令
	1. 显示文件头	
	2. -n 行数：显示制定行数
	3. -f：监听 不会退出文件 如果其他终端往里写数据了 会继续显示新增内容 要用ctrl+c退出
7. tail命令
	1. 显示文件尾
	2. -n 行数：显示制定行数
8. ln命令
	1. link
	2. make links between files
	3. inode
		1. inode#
		2. 时间
		3. 权限
		4. block的位置
	4. block
		1. 储存了子文件的文件名和inode
	5. 所以如果我要查d文件的inode号， 我需要找到它的上级文件的block，在查询d的inode号...层层递归。所以要从根目录开始，根目录的inode号是固定为2（1在创建内核的时候被占用了）
	6. 硬链接
		1. 源文件和硬链接会拥有相同的inode和block
		2. 引用计数增加
		3. 修改其中一个 另一个都改变
		4. 删除任意一个文件 另一个都可用
		5. 硬链接标记不清，很难确认硬链接文件位置 不建议使用
		6. 硬链接 不能链接目录 因为链一个目录 所有子文件都要链 所以linux不让瞎搞
		7. 硬链接不能跨分区 俩文件要zhi xiang同一个分区的同一个inode
		8. 两东西其实是一个文件 只是名字不同而已 就像一个教室两个门 前门进人人数改变 后面进人人数也改变 堵上一个门 一样能进教室
	7. 软链接 ln -s
		1. 软链接和源文件拥有不同的Inode和Block
		2. 引用计数不会增加
		3. 任意修改一个 另一个都改变
		4. 删除软链接，源文件不受影响，删除源文件，软链接不能使用
		5. 软链接没有实际数据，只保存源文件的Inode，不论源文件多大，软链接的大小不变
		6. 软链接的权限是最大权限lrwxrwxrwx，但是由于没有实际数据，最终访问时要参考源文件权限
		7. 软链接可以链接目录
		8. 也可以跨分区
		9. 软链接的标记特征明显 推荐使用
		10. 软链接移动要写绝对路径！！！！！否则很容易出错
		11. 其实可以理解成快捷方式 是为了照顾老手的使用习惯 因为很多升级改变了文件的位置 不好找

### 目录和文件都能操作的命令
1. rm命令
	1. -f：强制删除
	2. -i：交互删除 默认情况下就是
	3. -r：递归删除，可以删除目录
2. cp命令
	1. cp [选项] 源文件 目标文件
	2. copy
	3. -r递归复制 用于复制目录
	4. -a 相当于 -dpr 保证目标文件和源文件一模一样
	5. -d 如果源文件为软链接，则复制出的目标也为软链接
	6. -i 如果目标文件已经存在，则会询问是否覆盖
	7. -p 复制后目标文件保留源文件的属性，包括所有者 所属组 权限和时间
3. mv命令
	1. move
	2. 移动或重命名
	3. 移动目录不需要加-r
	4. mv 123 _tmp_ 把123这个文件或者目录原名移动到tmp文件下
	5. mv 123 234 把123重命名为234


### 基本权限管理
1. 权限介绍
	1. 带.的 表示受SELinux 保护的文件
	2. 共10项
		1. 文件的类型
			1. 具体类型 info ls查询
			2. 主要类型
				1. -：普通文件
				2. d：目录
				3. l：软链接
				4. 剩下的相对较常见的还有 b 块设备文件比如内存c 设备文件比如鼠标键盘 p 管道服务文件s 套接字文件 千万别动 例如可能导致要重装php或mysql
		2. 2-4 所有者权限
		3. 5-7 所属组权限
		4. 8-10 其他
		5. rwx分别代表读写执行权限
		6. 所有者权限优先于所属组权限
2. 基本权限命令
	1. chmod
	2. chmod [ugoa] [[+-=] [perm]]
		1. change file mode bits
		2. 赋予方式
			1. +
			2. -
			3. =
			4. 例子
				1. chmod u+x bcd 给bcd的所有者添加执行权限
				2. chmod g+w，o+w bcd
				3. chmod u-x，g-w，o-w bcd
				4. chmod u=rwx bcd
		3. 数字权限
			1. 4代表r
			2. 2代表w
			3. 1代表x
			4. 例子
				1. chmod 755 bcd
		4. 常用权限
			1. 644 基本权限
			2. 755 文件的执行权限和目录的基本权限
			3. 777 除了系统自带的 不允许手动赋予777 会造成安全隐患
				1. 有时候改了改了开源软件放进apache 报错权限不足，为了省事所以被改成了777，造成安全隐患
	3. chown命令
		1. change file owner and group
		2. chown [选项] 用户:所属组 文件或目录
			1. 也可用.分隔
		3. 注意：普通用户可以修改所有者是自己的文件的权限
		4. 注意：普通用户不能修改文件的所有者 哪怕是属于当前用户的文件 只有超级用户能修改所有者和所属组
		5. 测试
			1. 在root超级用户下
			2. 先添加用户 useradd user1
				1. 注意 添加用户就会自动添加进自动创建的同名组
			3. passwd user1
			4. 此处输入密码
			5. chown user1 bcd
	4. chgrp命令
		1. 修改所属组

3. 基本权限的作用（难点）
	1. 权限对文件的作用
		1. r：cat more less head tail等文件查看命令
		2. w：vim echo等修改文件数据的命令
			1. 注意：对文件有写权限 是不能删除文件的
			2. 如果想要删除文件，需要对文件的上级目录有写权限！原理是文件的原理 inode和block的内容，文件名和其对应的inode是存在于上级目录的block中的，而权限是针对inode所对应的block的，也就是说，对block的权限是储存在inode中的
		3. x：对文件来说执行权限是最高权限 也是风险最高的 代表该文件有了执行权限 是否能正确执行 不一定
	2. 权限对目录的作用
		1. r：ls
		2. w：touch rm cp mv等
			1. 对目录来说写是最高权限
		3. x：目录是不能执行的，但是如果目录拥有执行权限 对应到命令上就是可进入 可以执行cd命令
	3. 目录的可用权限
		1. 0:没有任何权限
		2. 5:基本的目录浏览和进入权限
		3. 7:完全权限
			1. 没有什么6权限 因为不能进入 拥有写权限没有意义
	4. 注意：权限对超级用户是没有意义的 不管怎么样实际都是777



### umask默认权限

1. 查看系统的umask权限
   - 默认用八进制数值显示umask的权限
     - 0022
     - 暂时我们忽略第一个数
     - 后面依次是022
     - 即
   - -S 用字母表示文件和目录的权限
2. umask权限的计算方法
   1. 新建文件的默认最大权限
      - 666
      - 执行权限对文件比较危险，不能在新建时默认赋予，必须用户手动赋予
   2. 新建目录的默认最大权限
      - 777
      - 执行权限就是进入目录，所以默认赋予
   3. 官方标准算法
      - umask需要使用二进制进行逻辑与和逻辑非联合运算得到正确的默认权限
        1. 将总权限（目录777 文件666）和umask转换为2进制
        2. 对umask取反
        3. 对两个值做与
        4. 转换为十进制即权限
      - 但我们可以这样理解
        - umask是我们希望从默认最大权限中去掉的权限
        - 如果本来有 则去掉
        - 如果本来就没有 维持原样
        - 所以 对文件来说 umask 033和022的结果都是644
   4. 注意
      - 要永久更改umask 要写入配置文件
        - /etc/profile
        - 环境变量配置文件
      - 否则都是暂时的更改



### 帮助命令

1. man命令
   1. manual
   2. man [命令]
   3. 快捷键
      1. 上下 移动一行
      2. PgUp PgDn 翻页
      3. g 第一页
      4. G/shift+g 最后一页
      5. q 退出
      6. /字符串 从当前向下搜索
      7. ？字符串 从当前向上搜索
      8. N 当搜索字符串时 使用N反向搜索
   4. 帮助级别
      1. 默认打开1级别 绝大部分命令只有1级别的
      2. 帮助级别
         1. 普通用户可以执行的系统命令和可执行文件的帮助
         2. 内核可以调用的函数和工具的帮助
         3. C语言函数的帮助
         4. 设备和特殊文件的帮助
         5. 配置文件的帮助
         6. 游戏的帮助
         7. 杂项的帮助
         8. 超级用户可执行的系统命令的帮助
         9. 内核的帮助
      3. man -f 命令 或者 whatis 命令
         - 查看命令拥有哪个级别的帮助
         - 小tip：新系统或者刚恢复快照 可能用whatis报错 可用makewhatis 解决
      4. man -k 命令 或者 apropos 命令
         - 查看命令相关的所有帮助
         - 只要包含命令的字符串都会被找到   不常用
2. info命令
   1. info命令比man更详细，是一套完整的资料
   2. 如果man找不到有用的信息，在用info
3. help命令
   1. 只能获取shell内置命令的帮助
   2. 作用很有限 一般不用
4. --help选项
   1. 绝大多数命令都可以使用--help选项来查看帮助
   2. 输出的帮助信息基本是man的简化版
   3. 例如 ls --help



### 搜索命令

1. whereis命令

   1. 搜索命令的命令 不能搜索文件
   2. 搜索位置和帮助文档的位置

2. which命令

   1. 搜索命令的命令 不能搜索文件
   2. 搜索位置和灵命的别名

3. locate命令

   1. 按照文件名搜索普通文件的命令
   2. 优点：按照数据库搜索，速度快，消耗资源少，数据库位置/var/lib/mlocate/mlocate.db
   3. 缺点；只能按照文件名来搜索文件，不能执行更复杂的搜索
   4. 注意：搜索前先更新库 updatedb 否则刚产生的文件夹可能找不着
   5. 注意：配置文件里会排除一些文件和目录 例如tmp下的文件是搜不到的
   6. 常用

4. find命令

   1. 按照文件名搜索

      1. -name

         - find [路径] -name [文件名]

         - 严格区分大小写

      2. -iname

         - 不区分大小写

      3. -inum

         - 按照inode去搜索文件

   2. 按照文件大小搜索

      1. -size
         - find . -size -15
           - 默认单位b 512字节
           - c for byte
           - w for 2字节
           - k for KB
           - M for MB
           - G for GB
           - 大小之前- 代表小于

   3. 按照修改时间搜索

      1. -atime 访问时间
      2. -mtime 修改时间
      3. -ctime 状态修改时间
      4. 前三个时间单位为天
      5. -amin -mmin -cmin 以分钟为单位
      6. 格式：find . -atime +5
         - -5 五天内
         - 5 五到六天前的那24小时
         - +5 六天之前

   4. 按照权限来搜索

      1. -perm
         - 支持+—
         - +444 搜索包含444种任意一个组的权限的文件 三个数任意一个大于等于4
         - -444 搜索全部包含权限模式的文件 三个数全部大于等于4
         - 444 搜索搞好等于权限模式的文件

   5. 按照所有者和所属组搜索

      1. -uid
      2. -gid
      3. -user
      4. -group
      5. -nouser 查找没有所有者文件 即外来文件 如光盘和U盘等 否则一般是垃圾文件 常用来搜索垃圾文件

   6. 按照文件类型搜索

      1. find . -type d abc 查找目录
      2. -type f 普通文件
      3. -type l 软连接文件

   7. 逻辑运算符

      - find 搜索路径 选项 搜索内容

      1. -a 与
         - find . -size +2k -a -type f
      2. -o 或
      3. -not 或者!   非

   8. 其他选项

      1. -exec

         - find 搜索路径 选项 搜索内容 -exec 命令2 {} \;

         - 把find命令的结果交给由-exec调用的命令2来处理 {}就代表find命令的查找结果
         - find . -size +2k -a -type f -exec ls -lh {} \;
         - 注意命令2不支持别名

      2. -ok

         - 区别是每执行一次命令2 就询问一次
         - -exec就直接处理了
         - -ok 比-exec适合执行删除

5. grep命令

   1. 用于在文件中搜索符合条件的字符串
   2. 如果需要模糊搜索，使用正则表达式进行匹配
   3. 选项
      1. -i 忽略大小写
      2. -n 输出其在原始文件里的行号
      3. -v 取反
      4. --color=auto 搜索的字符串红色高亮

### 通配符

完全匹配

?匹配1个任意字符

*匹配任意个数任意字符 可以为0个字符

[] 匹配其中任何一个字符

[-] 表示范围

[^] 表示取反



### 正则表达式

用于包含匹配

? 匹配0或1个前一个字符 属于扩展正则符 需要egrep来识别

\* 匹配任意个数前一个字符

* "a*" meaningless since it can be any string

^ 限位符 匹配行首

$限位符 匹配行尾

正则一般用来粗过滤 因为文本处理快 占用资源小 支持访问量大 所以一般先用正则粗过滤 然后用程序过滤

#### 对比find和grep

1. find默认完全匹配 grep默认包含匹配
2. grep搜索的是字符串



### 管道符

1. 命令1 | 命令2
2. 命令1的争取输出作为命令2的操作对象
3. 为啥有了-exec还要管道符呢
   1. ｜是文本流操作
   2. find不支持文本流操作 所以不支持管道符
4. 例子
   1. ll /etc/ ｜ more
   2. ll /etc/ ｜ grep
      - 注意此处不能用find 因为grep才是搜索字符串的 更别说find不支持文本流
   3. netstat -tuln 查询系统中所有开启的端口
      1. netstat -tuln ｜ grep 80
         - 注意这个是包含匹配 是包含80的端口
   4. netstat -an 所有的端口号
      1. enstat -an | grep ESTABLISED | wc -l
      2. 统计正在连接的数量



### 命令的别名

1. alias 别名=' 命令'
2. alias grep=' grep --color=auto'
3. alias ser =' service network restart'
4. 注意！！ 别名的优先级比系统命令高，不要和系统命令重叠
5. 默认是临时的改变 永久更改需要写入配置文件~/bashrc
6. 注意！！**放在/etc/下的配置文件 对所有用户生效 放在家目录~/下的只对该用户生效*



### 常用快捷键

1. ctrl+a 光标移动到行首
2. ctrl+e 光标移动到行尾
3. Tab 命令或文件补全
4. ctrl+c 强制终止当前的命令
5. ctrl+l 相当于clear
6. ctrl+u 删除或剪切光标到行首的命令
7. ctrl+y 粘贴ctrl+u的内容



### 压缩和解压缩命令

- 系统无所谓扩展名 这是个管理员看的 因为不同格式的压缩命令不同

1. .zip
   1. windows下的压缩格式
   2. zip [选项] 压缩文件名 源文件名
      1. -r 压缩目录
      2. -d 解压缩
   3. unzip 文件名
      1. -d 制定解压缩位置
   4. 不常用
   
2. .gz
   - .gz较古老 压缩比低 占用资源少
   - bz2压缩比高 消耗资源多
   1. gzip
   2. gzip [选项] 源文件
      1. -c 将压缩数据输出到标准输出中，可以用于保留原文件
         - gzip -c abc >> abc.gz
         - 非常规操作
      2. -d 解压缩
      3. -r 压缩目录
         1. **不会打包**
            1. gzip -r abc
            2. abc目录下的每一个文件都压缩了 但是目录本身没有变
   3. gunzip 文件名
      - 解压缩

3. bz2

   1. bzip2
   2. bzip2 [选项] 源文件名
      1. -k 保留原文件
      2. -d 解压缩
      3. -v显示解压详细信息
   3. bunzip2 文件名
   4. **不能压缩目录**

4. .tar格式   **打包不会压缩**

   1. tar [选项] [-f 压缩包名] 源文件或目录
      1. -c 打包
      2. -f 制定压缩包文件名 压缩包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名
      3. -v 显示打包文件过程
   2. tar -cvf anaconda-ks.cfg.tar anaconda-ks.cfg
   3. -x 解打包
      - 一般-xvf

5. **tar.gz 和 tar.bz2格式**

   1. tar [选项] 压缩包 源文件或目录
      1. -z 压缩和解压缩.tar.gz格式
      2. -j 压缩和解压缩.tar.bz2格式
   2. 所以 压缩 tar -zcvf 或者tar -jcvf
   3. 解压 tar-zxvf 或者tar -jxvf
   4. 只查看一下不解压 把c换成t就行了
   5. 解压缩到指定位置
      1. 解压缩的文件名后面 -C 解压路径
      2. tar -zxvf you.tar.gz -C abc/bcd
   6. 解压特定文件到指定位置
      1. tar -ztvf yui.tar.gz先看看里面有啥
      2. tar -zxvf yui.tar.gz -C /tmp test/cde
      3. 再解压其中的cde文件到/tmp中



### 关机和重启命令

1. sync数据同步
   1. flush file system buffers
   2. 刷新文件系统缓存
2. shutdown命令
   1. bring the system down
   2. -c 取消已经执行的shutdown命令
   3. -h 关机
   4. -r 重启
      - shutdown -r now
      - shutdown -r 05:30 最好不要在固定时间重启 比较危险 千分之几的几率存储设备出问题 不推荐让计算机自己执行 一般要有人看着
   5. 最安全的关机命令 会先保存各种东西再关
3. reboot命令
   1. 现在的系统中reboot也是安全的 而且不需要加入过多的选项
4. halt和poweroff
   1. 不推荐 不保存
5. init命令
   1. init是修改Linux运行级别的命令，也可以用于关机和重启，不建议使用



### 常用网络命令

1. 配置IP地址
   1. setup工具 （redhat系列专有）
   2. vi /etc/sysconfig/network-scripts/ifcfg-eth0    手工修改配置文件 主流方法
2. 重启网络服务
   - service network restart
3. 如果是虚拟机 需要侨界到有线网卡，并重启网络服务
4. 复制镜像有可能需要UUID（唯一识别符）
   1. 网卡配置文件里有
   2. 快照和当前系统UUID一样 或者 由于克隆虚拟机导致的UUID冲突
   3. vi /etc/sysconfig/network-scripts/ifcfg-eth0 删除MAC地址行
   4. rm -rf /etc/udev/rules.d/70-persistent-net.rules    删除MAC地址和UUID绑定文件
   5. reboot    重启Linux
   6. 此时UUID会重新计算 不可能像再相同

2. ifconfig命令
3. ping命令
   1. ping [选项] IP
      1. -c 指定ping的次数
      2. -b 探测整个网段 用于检测整个网段有多少台电脑
      3. -s 指定探测包的大小 感觉没啥用
4. netstat命令
   1. -a 列出所有网络状态 包括Socket程序
   2. -c 秒数：指定每隔几秒刷新一次网络状态
   3. -n：使用IP地址和端口号显示，不使用域名与服务名
   4. -t 显示使用TCP协议端口的连接状况
   5. -u 显示使用UDP.......
   6. -l 仅显示监听状态的连接
   7. -p 查看PID 看哪个程序占用了端口
      - netstat -tulnp
   8. -rn 可以查看网关
5. write命令
   1. 向其他用户发送信息
   2. w 看看谁在登陆中
   3. 登陆终端
      1. 本地字符终端tty1-6 使用快捷键alt+F1-6
      2. 本地图形终端 tty7 ctrl+alt+F7按住3秒 需要安装图形界面才有
      3. 远程终端 pts/0-255
   4. write 用户名 终端名
   5. 开始写sfsdfdg
   6. ctrl+d发送信息
6. wall命令
   1. 给所有人发送信息
7. mail命令
   1. 发邮件 mail 用户名
      1. mail 用户名
      2. 输入内容
   2. 查看mail
      1. 直接输入mail命令
      2. 输入标题号查看
      3. h键看标题
   3. 发送文件内容 常用
      1. mail -s “the subject” 用户名 /root/anaconda-ks.cfg
      2. -s "fsdfwe" 是邮件标题



### 系统痕迹命令

- 系统中的一些重要的痕迹日志文件，如/var/log/wtmp, /var/run/utmp, /var/log/btmp, /var/log/lastlog等日志文件，只能通过对应的命令查看，通过vim打开是乱码

1. w命令
   1. /var/run/utmp
   2. 第一行 系统时间 开机了多少时间 几个用户登陆中 系统前1分钟 5分钟 15分钟的平均负载
      1. 1分钟的负载超过核数 一般来说就是负载比较高了
      2. CPU和内存 70/90原则 cpu不要超过70%内存不要超过90%
   3. 第二行以后 用户名 终端名 IP 登陆时间 用户闲置时间 所有进程占用CPU时间 当前进程占用CPU时间 在干啥（-bash就是啥也没干 在等待）
2. who命令
   1. 也是看的w查看的日志
   2. 区别就是显示更简单
3. last命令
   1. 查看系统所有登陆过的用户信息
   2. /var/log/wtmp
4. lastlog命令
   1. 查看所有用户最后一次登陆的时间（包括系统用户）
   2. /var/log/lastlog
5. lastb命令
   1. 查看错误的登陆信息
   2. 比如密码输错了
   3. /var/log/btmp



### 挂载命令

1. mount命令基本格式

   - mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点

   1. linux所有储存设备都必须挂载
   2. 把设备名和一个空目录挂载
   3. mount
      1. 显示现在系统中挂载的设备
      2. 注意swap不用挂载 直接供内核访问
   4. mount -a 自动挂载 移动存储设备最好不要自动挂载 要是没插 会崩溃
      1. 命令会依据配置文件 /etc/fstab的内容 自动挂载
      2. 如果配置文件出错要修复 必须服务器现场
      3. 但现在来说 这个配置文件已经没有这么脆弱了 但是还是要非常注意
   5. -o里面都不建议修改 尤其是执行权限 容易有大问题 如果root所在分区不可执行 系统就崩溃了 无法启动

2. 光盘挂载

   1. mkdir /mnt/cdrom
   2. centOS6以后光盘设备名是/dev/sr0 以此类推
   3. 同时dev/cdrom是其软链接
   4. mount /dev/sr0 /mnt/cdrom
   5. 然后去挂载点访问光盘的内容
   6. 注意 一定记得卸载
      1. umount /dev/sr0
      2. 或者umount /mnt/cdrom都可以

3. U盘挂载

   1. fdisk -l   U盘跟硬盘共享设备名 所以不固定 要先查询
   2. 假设我们查到usb设备名为sdb1 格式为FAT32
   3. mount -t vfat /dev/sdb4 /mnt/usd/
   4. cd /mnt/usb/
   5. ls
   6. 发现中文都不能正常显示
      1. 要显示中文 首先要安装中文编码
      2. 终端要支持
      3. 注意本地终端不支持中文
      4. 但是远程终端是可以的
      5. 所以挂载时要手工指定中文编码
      6. mount -t vfat -o iocharset-utf8 /dev/sdb1 /mnt/usb/
      7. cd /mnt/usb/
      8. ls
      9. 这时应该可以了
   7. 用完卸载

4. 挂载NTFS分区 （默认不识别 就算挂载了 最多只读）

   1. Linux的驱动加载顺序
      1. 驱动直接放入内核中，这种主要是系统加载必须的驱动，数量较少
      2. 驱动以模块的形式放入硬盘，大多数驱动都用这种方式，保存位置是/lib/modules/kernel/      驱动模块是以.ko结尾的
      3. 驱动可以被Linux识别，但是系统认为这种驱动一般不常用，默认不加载，如果加载需要重新编译内核，而NTFS文件系统的驱动就属于这种情况
      4. 硬件不能被Linux内核识别，需要手工安装驱动。当然前提是厂商提供了该硬件针对Linux的驱动，否则就要自己开发驱动了（笑）
   2. 使用NTFS-3G安装NTFS文件系统模块
      1. 后面学了安装再说



## vim编辑器

- vim是全屏幕纯文本编辑器，是vi编辑器的增强版

### vim基本使用

1. vim的工作模式
   1. 命令模式
      1. 用快捷键操作 无法写入
      2. ZZ 保存退出
      3. 插入命令
         1. a 追加 在光标坐在字符后插入
         2. i 插入 在光标坐在字符前插入
         3. A 光标所在行尾插入
         4. I 光标所在行首插入
         5. o 光标下插入新行
         6. O 光标上插入新行
   2. 输入模式
      1. 输入：进入编辑模式
   3. 编辑模式（末行模式）
      1. ：w 保存不退出
      2. ：w 新文件名   相当于另存为
      3. ：q不保存退出
      4. ：wq 保存退出
      5. ：！强制
      6. ：q！强制不保存退出，用于修改文件后不保存数据退出
      7. ：wq！强制保存退出，当**文件的所有者或者root用户**，对文件没有写入权限时候（比如000），强制写入数据使用

### 命令模式操作

1. 光标移动
   1. hjkl 左下上右
   2. 文件首尾
      1. gg 移动带文件头
      2. G 移动到文件尾
   3. 行首行尾
      1. ^ 移动到行首
      2. & 移动到行尾
   4. 移动到指定行
      1. :n 其中n是数字
2. 删除和剪切
   1. x 删除单个字母
   2. nx 删除n个字母
   3. dd 删除剪切单行
   4. ndd 删除剪切多行
   5. ：n1,n2d 删除指定范围 例如:3,5d
   6. p 粘贴到光标后
   7. P 粘贴到光标前
   8. dG从光标所在行删除到文件尾
   9. yy 复制单行
   10. nyy复制多行
   11. u 撤销
   12. ctrl+r 反撤销
   13. r 替换光标所在处字符
   14. R 从光标所在处开始替换字符，按ESC结束

### 末行模式

1. vim 配置文件 ~/.vimrc
   1. ：set all 进行查看
   2. ：set nu   ：set nonu   显示与取消行号
   3. ：syntax on   ：syntax off   是否根据语法显示相关颜色的帮助
   4. ：set hlsearch  ：set nohlsearch   是否将查找的字符串高亮显示
   5. ：set ruler   ：set noruler   是否显示右下角状态栏
   6. ：set showmode   ：set noshowmode   是否左下角显示模式状态栏
   7. ：set list   ：set nolist  是否显示隐藏字符   tab是^I 回车是$

### 查找

- /查找内容   从光标所在行向下查找
- ?查找内容   从光标坐在行向上搜索
- n 下一个
- N 上一个

### 替换

- ：1，10s/old/new/g   替换1到10行所有old为new
  - s代表替换
  - g代表替换所有
- ：%s/old/new/g   替换整个文件的old为new
  - %是个变量 这里代表整篇文档
- ：1，10s/^ /#/g 注释1到10行
- ：1，10/^#//g 取消注释
- ：1，10/^\/\//g 1到10行 行首加入//
  1. 或者 按esc进入命令模式
  2. ctrl+v
  3. 上下移动选取
  4. shift+i and type
  5. esc

### vim使用技巧

1. 在vim中导入其他文件内容或命令结果
   1. ：r 文件名
      * 把文件内容导入光标位置
2. 在vim中执行系统命令
   1. ：！命令
      - 暂时跳出vim执行一次系统命令
3. 导入命令结果
   1. ：r !命令
4. 设定快捷键
   1. ：map 快捷键 快捷键执行的命令
   2. ：map ^P I#\<ESC\>   按ctrl+p在行首加入注释
   3. ：map ^B ^x    按ctrl+b 删除行首第一个字母
      - 注意 ^ 使用 ctrl+v输入的 普通的^并不起作用
   4. 要永久生效 写入~/.vimrc
5. 字符替换
   1. ：ab 原字符 替换为字符
      - 在vim编辑中 有时需要频繁输入长字符串 例如邮箱 我们可以用另一个字符串代替 每次输入源字符 自动变
6. 多文件打开
   1. vim -o abc bcd
      - 上下分屏打开两个文件
      - ctrl+w 再按方向键 在文件之间跳转
      - 如果要左右分屏 则-O



## 软件包安装

### 软件包分类

- 源码包
- 二进制包

1. 源码包
   1. 开源 可以自己动手改
   2. 自由选择所需功能
   3. 软件是便衣安装，更加舍和自己的系统，稳定，效率高
   4. 卸载方便
   5. 安装过程步骤较多，尤其安装较大软件合集时，容易出现拼写错误
   6. 编译时间长，比二进制安装时间长
   7. 因为是编译安装，安装过程中一旦报错新手很难解决
2. 二进制包
   1. DPKG包 一般叫Deb包 因为由Debian开发
   2. RPM包 由Red Hat开发
   3. 简单 命令实现安装升级查询卸载
   4. 功能选择不灵活
   5. 依赖性
   6. 看不到源代码
3. 软件包选择建议
   1. 源码包：如果服务是给大量客户端提供访问的，建议使用源码包，源码包效率更高
   2. RPM包：如果程序是给少量用户访问，或者本地使用的，建议RPM包，因为RPM管理

### 依赖性

1. 树形依赖
   - a --> b --> c
2. 环形依赖
   - a --> b --> c --> a
   - 解决办法 同时安装
3. 模块依赖
   1. 很多时候 缺的库根本不知道从哪找
   2. 还好现在我们有网站 www.rpmfind.net
   3. 不过我们现在有两种安装方式
      1. 手工安装
      2. yum安装 是一种链接redhat的在线安装

### rpm

1. rpm包命名规则
2. 以阿帕奇为例：httpd-2.2.15-15.e16.centos.1.i686.rpm
   1. 进程名 版本 发布次数 适合的平台 硬件平台 
   2. 包全名：如果操作的是为安装软件包，则使用包全名，且用绝对路径
   3. 包名：如果操作的是已经安装的软件包，系统会产生数据库/var/lib/rpm/   所以使用包就行了 而且在任意路径下都行
3. 安装命令
   1. rpm -ivh 绝对路径下包全名
      1. 然后根据依赖层层安装
      2. 建议不要给rmp安装在指定路径 就默认就好了 作者觉的哪好就在哪 还有一个原因是service命令是在固定位置搜索的
      3. 另外rmp包管理系统是有卸载命令的 数据库记录安装位置 不怕装得这一个那一个 源码包则不行 必须手动选择安装路径否则很难卸载
      4. 如果非要重新定义安装路径 在整个命令后面 --prefix=/dsf/dfd/sd/
   2. --nodeps 不检测依赖性安装 不建议
   3. --force 强制安装 不管安没安过 如果不消息误删了部分文件 可以用这种方法
   4. --test 不会安装 检测一下依赖性
4. 启动命令
   1. service可以启动大部分的rpm包
      1. service httpd start 也可以restart和stop和status
      2. /etc/rc.d/init.d/httpd start 更标准 注意这个目录下的阿帕奇是通过软链接启动的
      3. 其实service就是搜索的这个目录启动服务的
      4. 注意阿帕奇中的网页文件 在/var/www/html/
      5. 写完网页之后就好了 如果没有修改配置文件 是不需要重启阿帕奇的
      6. 阿帕奇的配置文在/etc/httpd/conf/httpd.conf
5. rpm包升级
   1. rpm -Uvh 包全名
      - -U 升级安装 如果没有安装过 直接安装
      - -F 必须有旧版本才能升级安装
6. rpm卸载
   1. rpm -e 包名
      - -e 卸载
      - --nodeps 不检查依赖 不推荐
   2. 按照安装顺序倒序卸载
   3. 注意不要用yum卸载 因为yum卸载不检查除卸载程序以外的依赖 而且也不知道包名 有可能装不回来
7. 查询（yum无法取代）
   1. rpm -q 包名
      1. 查询的是客户端
      2. yum查的是服务器端的
   2. -a 所有
      1. 我们可以利用grep查询所需的
      2. rpm -qa ｜ wc -l
      3. rpm -qa ｜ grep httpd
   3. rpm -qi 包名
      1. -i 软件包说明
   4. rpm -qip 包全名
      1. 查询未安装包的信息
   5. rpm -ql 包名
      1. 确认软件包的安装位置和完整的目录信息
   6. rpm -qlp 包全名
      1. 查询未安装包打算装在哪
   7. rpm -qf 系统文件名
      1. 查询系统文件属于哪个软件包
   8. rpm -qR 包名
      1. 查询依赖包 没啥用 装没装无法知道
8. 验证
   1. rpm -V 已安装包名
      1. 校验已安装的文件
      2. 查询结果
         1. S：文件大小是否改变
         2. M：文件的雷总或文件的权限（rwx）是否改变
         3. 5：MD5完整性校验 可理解成文件内容是否改变
         4. D：设备的主从代码是否改变
         5. L：文件路径
         6. U：文件所有者
         7. G：文件所属组
         8. T：修改时间
         9. 文件类型（以apache为例）
            1. c 配置文件 config file
            2. d 普通文档
            3. g 鬼文件 很少见 就是该文件不应该属于这个rpm包
            4. l 授权文件 license file
            5. r 描述文件 readme
      3. 这个校验是和包里面的原始值做对比的 但如果原始值被改了呢？ 答案是数字证书！从官网那里导入数字证书 保证原始值是符合官方验证的 是原厂包
         1. rpm -qa ｜ grep gpg 查询相应的数字证书 此处我们看的数字证书是包含GPG的 如果结果error 就是没导入
         2. rpm --import 包名
         3. 再查一遍看看
         4. 记住 重要度非常高！！！
   2. rpm -Vf 系统文件
9. rpm包中文件提取命令
   1. 如果我们不是误删除文件 而是误修改了 这时候强制覆盖安装没用 它只会清空配置内容 不会修改已存在的文件的内容
      1. 注意 平常修改服务器文件 修改之前要备份 就放在同样的目录下 加个标记就行了 比如后缀.bak
      2. cpio命令（太复杂 不用）
         1. cpio -o [vcB] > [文件｜备份]
         2. cpio -i [vcdu] < [文件｜备份]
      3. cp命令 （不用 cp只能拷贝到同一个硬盘 不能把鸡蛋放在同一个篮子里）
   2. rpm2cpio 包全名 ｜ cpio -idv .加上文件绝对路径
      1. rpm2cpio 将rpm包转换为cpio格式的命令
10. rpm包在线安装（yum安装）
    1. yum源  文件解析
    2. [搭建本地yum源](https://www.bilibili.com/video/BV1ut411a7ro?p=61)
    3. yum命令
       1. 查询（查询的是服务器并不是当前客户端 不能替代rmp的查询）
          1. yum list 列出所有可用软件包 可用于区分来自哪个yum源
          2. yum list 包名
          3. yum search 关键字
          4. yum info 包名
       2. 安装
          1. yum -y install 包名   注意yum不用区分包名包全名 因为yum源包含了相关信息
             1. -y 自动回答yes
             2. 自动解决依赖问题
       3. 升级
          1. yum -y update 包名
          2. yum -y update      这个是升级本机所有软件包 包含内核 一般不用 否则可能有重大系统隐患 centOS5之前是禁止的
       4. 卸载
          1. yum remove 包名
             1. 不要用 无视依赖强行卸载包及其依赖链
             2. 老手 并熟悉包才用
11. yum组管理命令
    1. 很多情况下我们无法知道包名 比如由于语言的问题
    2. yum grouplist   查询已安装的组
    3. yum groupinfo 软件组名
    4. yum groupinstall 组名
    5. yum groupremove 组名



### 源码包

- 必须指定安装位置 除非有些指定了位置会导致后续安装包找不到其位置报错

1. 安装

   1. 下载
   2. 解压
   3. 进入解压目录
   4. ./configure --prefix=安装地址  编译前准备   现在有些变成cmake了
      1. 作用1: 检测系统环境
      2. 作用2：自定义功能选项
      3. 作用3: 把前两个的结果写入Makefile文件 后续的操作都依靠这个文件
   5. make   编译   注意4和5是不会写入文件的 如果报错 解决后 只要用make clean 清除临时文件就行了
   6. 源码包报错：
      1. 安装过程停止
      2. 出现了错误关键词
      3. 解决问题
      4. make clean：清空编译内容
   7. make install 编译安装
      1. 此时如果报错 之前的安装过程是有写入的！
   8. 注意要看安装文档INSTALL 看看各种文件安装到哪了

2. 打补丁

   1. 补丁的生成（很少见了）

      1. diff 选项 old new

         - diff -Naur 绝对路径 绝对路径 > txt.patch

         1. 比较old和new文件的不同
         2. -a 将任何文档当作文本文档处理
         3. -b 忽略空白造成的不同
         4. 。。。等等 看文档吧

   2. 打入补丁

   3. patch -pn < 补丁文件

      1. [具体n写几 参见视频8分钟左右](https://www.bilibili.com/video/BV1ut411a7ro?p=66)

3. 删除

   1. 源码包没有删除 直接删除安装目录即可



### 脚本安装包

- 用一个脚本封装安装过程
  - 优点：快
  - 缺点：版本 功能 安装位置等都得听作者的
- 案例：Webmin安装
  - 用浏览器来管理Linux
  - 下载
  - 放入Linux
  - 解压缩
  - 进入目录
  - ./setup.sh
  - 完事
  - 怎么访问？浏览器属通过p：端口访问



## 用户管理

- 防内大于防外 权限划分防患于未然

### 用户相关文件

1. /etc/passwd   用户信息文件
   1. 每一行都是一个用户 大部分都是系统用户 用来启动相应的服务
   2. 有7列
      1. 用户名
      2. 密码标识 x代表有密码
         1. 用户名在etc/shadow中加密后显示了
         2. 如果没x标志 系统就不会要求密码
      3. 用户ID 
         1. 0 是超级用户UID
            1. 如果把普通用户的UID改为0 就成了root   一般情况下不要弄俩root
         2. 1-499 系统用户UID也就是伪用户 所有安装的软件都会需要一个为用户启动相应的服务 （65534也是 匿名用户）
         3. 500-2^32 普通用户UID
      4. 组ID
         1. 具体是啥要去查/etc/group
      5. 说明
      6. 家目录
      7. 登陆shell   也就是权限   普通用户是/bin/bash
         1. 伪用户都是/sbin/nologin
2. /etc/shadow   影子文件
   1. 9 列
      1. 用户名称
      2. 用户密码（SHA512加密）
         1. 伪用户都是*或者！！
         2. 如果想让一个用户暂时不能登陆 在密码前面加个！
      3. 更新密码的时间
         1. 时间戳 1770.1.1开始算 +天数
         2. echo $(($(date --date="2020/08/01" +%s)/86400+1))
      4. 限制两次密码修改的间隔时间 跟3相比
      5. 密码有效期 默认99999 也是跟3比的
      6. 密码到期前的警报天数 和5相比
      7. 密码到期之后的宽限天数 跟5相比 默认-1 意思是无限宽限
      8. 密码的失效时间
         1. 比如会员有效期 过了就到期了
         2. 也是写的时间戳 到了这个时间就失效了 失效了会在密码段加1个！
3. /etc/group   组信息文件
   1. 4列
      1. 组名
      2. 组密码位
         1. 在/etc/gshadow
         2. 并不推荐
         3. 是用来管理组的
         4. 踢人 加人 是有管理风险的 一般不推荐下放
      3. GID
      4. 附加组
         1. 除了初始组（只能且必须有一个）以外的组
         2. 所以只建议改附加组 不建议改初始组
         3. 因为改了之后忘了不好查 这不显示
4. 用户的家目录
5. 用户的邮箱目录
   1. /var/spool/mail/用户名
6. 用户模版目录
   1. /etc/skel/
   2. 生成的用户都会拷一份放在新用户的家用户里
   3. 可以用来给新用户写警告文档或者操作规范等



### 用户管理命令

1. 添加用户
   1. 本质就是添加信息到下列文件
      1. /etc/passwd
      2. /etc/shadow
      3. /etc/group
      4. /etc/gshadow
      5. /home/用户名
      6. /var/spool/mail/用户名
   2. useradd命令
      1. useradd 选项 命令
         1. -u 550 指定UID
         2. -g 组名 指定初始组
            1. useradd -g t1 p1
            2. 此时p1的初始组是t1组
            3. p1组是没有建立的
            4. t1组还会是t1的初始组 当然目前t1可能还没建立
            5. 非常混乱 不推荐！
         3. -G 组名  指定附加组
         4. -c 说明 添加说明
         5. -d 目录 手工指定家目录 不需要事先建立
         6. -s shell   /bin/bash
      2. /etc/default/useradd 和 /etc/login.defs
2. 设置密码
   1. 对于超级用户
      1. passwd 选项 用户名
         1. -l 暂时锁定用户
         2. -u 解锁用户
         3. --stdin 可以通过管道符输出数据作为用户密码 主要在批量添加用户时使用
            1. 记得history -c 否则相当于明文存在了历史记录里
         4. chage -d 0 用户名
            1. 把时间戳改成0
            2. 登陆就会让该用户改密码
   2. 对于普通用户
      1. passwd
3. 用户信息修改
   1. usermod命令 时修改已添加的用户
      1. -G 修改附加组
      2. -L 所用户
      3. -U 解锁
      4. 一般不改用户名 容易晕菜 建议删了 再建
4. 用户删除
   1. userdel -r 用户名
      1. 不会删除家目录 成为了垃圾文件
      2. 所以-r是必备的
5. 切换用户登陆
   1. su - 用户名
      1. 注意使用一些命令 仍会显示切换前的信息
      2. 中间必须加减号 代表家目录也切换了



### 用户组管理

1. 组添加

   1. groupadd
   
2. 组删除

   1. groupdel 注意 作为用户的初始组的组没法删除 必须先改变其状态

3. 组内添加删除用户

   1. gpasswd -a 用户 组名   加入组
   2. gpasswd -d 用户 组名   踢出组
   3. 一般这个比较常用 而不是usermod

4. 改变有效组

   - 所谓有效组 就是新建文件之后的默认所属组 注意用户必须拥有超过一个所属组才能改变有效组

   1. newgrp 组名

5. 组权限实验

   1. 分配权限的时候要先搞清身份 再分配权限



## 权限管理

### ACL权限

1. 概述

   1. 用于解决用户对文件身份不足
   2. 直接让用户对特定文件或者目录有权限

2. 开启ACL

   1. dumpe2fs -h /dev/需要查询的分区

   2. 如果没有开启 手工开启

      mount -o remount，acl /

      重新挂载分区 并挂载加入acl权限

   3. 也可以通过修改/etc/fstab文件永久开启ACL文件
      vi /etc/fstab

      编辑完mount -o remount /

3. ACL基本命令

   1. getfacl 文件名 查询ACL的权限

   2. setfacl -m u：用户名：权限 文件名

      setfacl -m g：用户名：权限 文件名

   3. -m 设定acl权限

   4. -b 删除acl权限

   5. -x：用户   删除某用户的acl权限

   6. -R 递归  只能用于目录  **对以前建立的文件生效**

      setfcal u：user4:5 -R /www/
      1. 但是之后新建的文件不满足acl权限
      2. 这时候加一个d **对以后新建的文件生效**
      3. setfcal d：u：user4：5 -R /www/

   7. **注意  ACL权限递归之后 很容易出现权限溢出 因为文件的执行文件是很危险的 但是目录的执行权限是必须的 如果你对目录递归了 之后的目录下的文件都有了执行权限   必须用脚本实现区分文件和目录的权限赋予！！！**

   8. 最大有效权限mask

      1. mask权限是能赋予acl权限的上线
      2. 两个权限做与才是真正的权限
      3. 默认是rwx 建议默认就好了

   9. 删除ACL权限

      1. setfacl -x u：用户名  文件或目录名
         1. 删除置顶用户或用户组的acl权限
      2. setfacl -b 文件或目录名
         1. 删除文件或目录的所有acl权限



### sudo授权

- 给普通用户赋予部分管理员权限
- /sbin/和/usr/sbin/目录下只有超级用户才能使用

1. 赋予的权限越详细，普通用户得到的权限越小
2. 在root身份下 visudo
   1. 用户名 ALL=/sbin/shutdown -r now
   2. 格式其实是 用户名 被管理主机的地址=（可使用的身份） 授权命令（注意是绝对路径）
3. 回到对应用户
   1. sudo -l 查询啥命令可以sudo
   2. 然后 sudo /sbin/shutdown -r now
4. 举例：我想授权一个用户管理我的web服务器 可以使用apache管理脚本 可以修改apache配置文件 可以更新网页内容
   1.  visudo
   2. user1 192.168.0.156=/etc/rc.d/init/httpd reload, /etc/rc.d/init.d/httpd configtest
5. 举例：授权aa用户可以添加其他普通用户
   1.  visudo
   2. aa ALL=/usr/sbin/useradd
   3. aa ALL=/usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd "", !/usr/bin/passwd root



### 文件特殊权限 SetUID，SetGID，Sticky BIT

- 前两个非常危险 禁止手动赋予
- 对应数字4，2，1

1. ​    SetUID
   1. 只有可以执行的二进制文程序才能赋予SetUID
   2. 命令执行者要对该程序拥有执行
      1. passwd这个命令其实是有SetUID的 因为它实际上写入了管理密码的shadow文件 但这个文件本应是root才能写的
   3. 命令执行者在执行该程序时获得该程序文件属主的身份
   4. SetUID权限仅仅在该程序的执行过程中有效，也就是说身份改变只在程序执行的过程中有效
      1. 建议
         对系统中默认的应该具有的SetUID列一个列表，定时检查有没有这之外的文件被设置成了SetUID权限
      2. 检测SeUID的脚本
2. SetGID
   1. 针对文件的作用 和SetUID相似
      1. 唯一的区别是执行过程中会变成相应的所属组
      2. 同样高风险
   2. 针对目录的作用 无风险
      1.  没啥太大的作用
      2. 如果执行者对该目录拥有7的权限（这个本身就挺有风险。。。others的权限是7。。。）
      3. 新建了文件之后 文件的所属组是文件本来的所属组 而不是执行者的所属组
      4. 可能在容器里还有用
3. StickyBIT
   1. 本身没啥风险 但是跟上面那个一样 风险在于文件的权限需要777
   2. 就算普通用户对该目录有7的权限 也只能删自己的文件 不能删除其他人的文件



### chattr权限

- 是可以限制root的

1. 命令格式
   1. chattr [+-=] 选项 文件或目录
   2. i 如果文件则所有的操作都锁了 如果是目录则目录下的文件可以改
   3. a 文件：能增加数据 不能删除 不能修改。 目录：能新建和修改 不能删
2. lsattr 文件
   1. 查看chattr权限
   2. 查看目录要加-d ！！！！
   3. 很容易忘 因为ls是看不出来的



## 文件系统管理

### 硬盘结构

1. 硬盘逻辑机构
   1. 每个扇区大小是固定的 512B 是磁盘的最小存储单位
2.  接口
   1. IDE
   2. SATA
   3. PCI-E



### 文件系统

1. Linux文件系统特性
   1. super block
   2. group
   3. block
2. 常见文件系统
   1. ext4
   2. xfs 安全性更好 不容易丢数据 大文件读写更好
3. 常用的硬盘管理命令
   1. df命令
      1. 统计分区大小
      2. df -ahT
      3. 显示特殊文件 人性化显示 显示文件类型
      4. 一般就用-h
   2. du命令
      1. du 选项 目录或文件名
         1. -a 显示每个子文件的磁盘占用 而不是默认的仅显示子目录
         2. -h 人性化显示
         3. -s 统计总占用量 不列出子目录和子文件的占用量
      2. ls统计的目录大小是不准确的 他统计的是保存子文件的文件名和inode的地方的大小 所以大部分的大小都是4k的倍数 这是由于分区的block大小决定的
      3. du -h 目录 和df -sh 目录 统计的大小是不一样的
         1. 区别是因为太久没重启 临时文件和垃圾文件没有释放
         2. du是统计文件大小，统计的文件大小是准确的
         3. df是统计空间大小 统计的剩余空间是准确的
   3. fsck 文件系统修复命令
      1. 开机自动的 一般不用
   4. 显示磁盘状态 dumpe2fs
      1. dumpe2fs /dev/sda3
   5. stat 文件名 查看文件的详细时间
   6. 判断文件类型
      1. file 文件名
      2. type 命令名
4. **手动分区**
   1. fdisk -l
      1. 查看分区
   2. fdisk /deb/sdb
   3. 输入m查看帮助
   4. n 新建分区
      1. 分区号
      2. p主分区
         1. first cylinder起始柱面 1
         2. last cylinder终止柱面 +20G
      3. e扩展分区
   5.   p 查看分区
   6. w保存退出
5. 格式化
   1. mkfs -t ext4 /dev/sdb1
   2. 注意扩展分区无法格式化 只能格式化主分区和逻辑分区
6. 建立挂载点
   1. mkdir /disk1
   2. mount /disk1 /dev/sdb1
7. 查看
   1. mount 查看所有已挂载分区和光盘
   2. fdisk -l 查看系统分区
   3. df 查看分区占用百分比
8. 自动挂载
   1. 修改分区自动挂载文件
   2. vi/etc/fstab 注意此文件直接参与系统启动，如果修改错误，系统启动报错
   3. 6列
      1. 分区文件名 或者UUID号
         1. 最好是UUID号，因为比如老硬盘坏了 换了个新的但是挂载的名字一样 会报错 但UUID是唯一的，换了盘也能区别
         2. 查看UUID的方法
            1. dumpe2fs /dev/sdb5
            2. ls -l /dev/disk/by-uuid/
      2. 挂载点
      3. 文件系统
      4. 挂载选项
      5. 1 是否可以被备份 0不备份 1每天备份 2不定期备份
      6. 2 是否检测磁盘fsck 0不检测 1启动时检测 2启动后检测
         1. 建议只有根分区启动时检测 其他2 否则启动很慢
9. 重启测试 mount -a 或者 reboot
10. /etc/fstab 文件修复
    1. 前提是要拿到本机
    2. 远程无法修复
    3. 由于启动未成功 网卡没生效 而且分区也只是只读挂载
    4. 必须 mount -o remount，rw /
    5. vi etc/fstab
    6. 修改保存退出
    7. reboot
11. **parted** **命令分区**
    1. ：Linux有两种常见的分区表（主引导记录分区表）和GPT分区表（GUID分区表）
       1. MBR分区表：支持的最大分区是2TB 最多支持4个主分区 或者3主分区1扩展分区
       2. GPT分区表：最大支持18EB的分区，支持128分区 其中一个系统保留分区 127个用户自定义分区
    2. 注意 **一定要把etc/fstab 自动挂载里面的相应的硬盘删了 否则重启会报错**
    3. 分区：parted 交互模式
       1. 修改etc/fstab
       2. parted /dev/sdb
       3. help获取命令
       4. print 打印列表
          1. 其中msdos就是MBR分区
       5. 修改成GPT分区
          1. mklabel gpt
       6. print
          1. 分区消失
          2. 这就是为什么要修改那个表
       7. quit
       8. reboot
       9. parted /dev/sdb
       10. mkpart 建立分区
           1. 名字 disk1 用来区分的 没啥用
           2. 系统类型 只能ext2 
           3. 大小
       11. 格式化 mkfs （注意这个是parted交互内的）
       12. quit
       13. 要格式化ext4文件系统 要用linux的mkfs
           1. mkfs -t ext4 /dev/sdb1 
       14. 挂载
           1. mount /dev/sdb1 /disk1/
       15. 修改自动挂载文件
       16. 测试重启
       17. 如果要调整大小
       18. 卸载分区 umount
       19. resize命令 不常用 因为可以用LVM
    4. **swap分区**
       1. free -h   查内存 能看到swap 是作为内存的缓冲的
          1. buffer是用来提高写入速度的
          2. cache 是用来提高读取速度的
       2. 分区 并修改swap ID
          1. fdisk /dev/sdb
          2. n
             1. p
          3. t 修改ID
             1. 选择分区
             2. 82
          4. 格式化
             1. mkswap /dev/sdb1
          5. free -h
          6. swapon /dev/sdb1
             1. 这时暂时生效的
             2. 要修改/etc/fstab
                1. /dev/sdb1 swap swap defaults 0 0
          7. 测试重启



## 高级文件系统管理

### 磁盘配额

1. 概念
2. 条件
   1. 内核支持
      1. grep CONFIG_QUOTA /boot/config-2.6...........
   2. 安装了quota包
      1. rpm -qa ｜ grep quota
3. 概念
   1. 用户配额和组配额
      1. 组配额几乎没有可用性 因为组配额是先到先得的 可能头几个用户全用完了
      2. 磁盘容量限制和文件个数限制
         1. 因为空间和inode数量都是有上限的
      3. 软限制和硬限制
         1. 软限制是发出警告
         2. 硬限制就不能用了
      4. 宽限时间
         1. 超过软限制之后 超过宽限时间之后 变为硬限制
         2. 默认7天
4. 磁盘配额规划实验
   1. 首先规划出一个分区
   2. 建立被限制的用户和用户组
      1. 假设需要限制user1，user2，user3用户
      2. 组就算了 不怎么使用
   3. user1 50MB 40MB 无限
      1. useradd user1
      2. passwd user1
      3. 输入密码
      4. mount -o remount，usrquota，grpquota /disk
         1. 在分区上开启磁盘配额功能
         2. 想要永久生效 需要修改/etc/fstab
            1. vi /etc/fstab
            2. /dev/sdb1 /disk ext4 default，usrquota，grpquota 0 0
            3. 此种方式需要重启生效
            4. 先用4临时生效 在改 可以先临时生效 重启后也会永久生效
      5. quotacheck 选项 分区名 生成磁盘配额  
         1. 需要关闭**SELinux** 否则报错
            1. getenforce
            2. setenforce 0
            3. getenforce
            4. 临时关闭
            5. 永久生效还得改配置文件/etc/selinux/config
         2. quotacheck -avu 
            1. 如果是根分区还要加个m选项 强制
            2. 因为根分区正在使用中
      6. edeuota 选项 用户名   设置配额限制
         1. -u设置用户配额
            1. 前三项是block的限制 是大小
            2. 后三项是inode的限制 为文件数量的限制
            3. 注意 **block和inodes不能改** 
      7. quotaon 选项 分区名  启动用户配额
         1. -avu 自动 显示过程 开启用户配额
      8. quota 选项 用户  查询用户配额
         1. -uvs 用户 详细显示 人性化显示
      9. repquota -avus 查分区的
      10. 用user1测试
          1. cd /disk/
          2. dd if=/dev/zero of=/disk/testfile bs=1M count=60
             1. 建立testfile 往目标目录写入60个1M文件 直到写完或写满
   4. 磁盘配额的其他命令
      1. 复制命令
         1. edquota -p user1 -u user2
            1. 将user1的配额复制到user2
         2. 非交互设定用户磁盘配额
            1. setquota -u 用户 软限制 硬限制 个数软限制 个数硬限制 /disk/
            2. 这个适合写脚本 因为不需要进入edquota交互界面
   5. 更改宽限时间
      1. edquota -t

### LVM逻辑卷管理

1. 简介
   1. 与sda1 sda2这种传统主分区不同 逻辑分区可以动态调整大小
   2. 如果硬盘不够了 还能把新的加入进去
   3. 实际工作中 至少也是LVM
2. 物理卷 PV：真正的物理硬盘或分区
3. 卷组 VG：多个物理卷的组合，可以来自于一块硬盘，也可以来自其他
4. 逻辑卷 LV：卷组是一个逻辑硬盘，硬盘必须分区才能使用，这个分区我们称做逻辑卷
5. 物理扩展 PE：最小单位是4MB 是逻辑卷的最小单位 但它不是block 最后还要格式化成block
6. 建立LVM的步骤
   1. 硬盘分区 把ID号改成8e
      1. 具体操作往回看
   2. 建立物理卷
      1. pvcreate /dev/sdb5
      2. pvcreate /dev/sdb6
      3. pvcreate /dev/sdb7
      4. pvscan
      5. pvdisplay 查看
   3. 建立卷组
      1. vgcreate vg /dev/sdb5 /dev/sdb6
   4. 添加物理卷
      1. vgextend vg /dev/sdb7
   5. 添加逻辑卷
      1. 建立逻辑卷
         1. lvcreate 选项 -n 逻辑卷名 卷组名
            1. -L 容量   指定逻辑卷大小
            2. lvcreate -L 3G -n userlv vg
         2. 格式化和挂载
            1. mkfs -t ext4 /dev/vg/userlv
            2. mkdir /disklvm
            3. mount /dev/vg/userlv /disklvm/
         3. 查看
            1. lvdisplay
         4. 调整逻辑卷大小
            1. lvresize 选项 逻辑卷设备文件名
               1. -L 容量：安装容量调整大小 
               2. lvresize -L 4G /dev/vg/userlv
               3. 把userlv调整到4G
               4. 然后我们要让分区知道大小变化了 所以把整个逻辑卷都加入到/disklvm分区
                  1. 所以我们有调整分区大小的命令 这就是LVM的优势
                     1. resize2fs 选项 设备文件名 调整的大小
                        1. 设备文件名：指定调整哪个分区的大小
                        2. 调整的大小：指定把分区调整到多大 要加M G等单位 如果不加大小，会使用整个分区
                  2. resize2fs /dev/vg/userlv 把整个调整过的逻辑卷加入到分区中
         5. 完事 不需要重新挂载或重启

### Raid



## shell基础

### shell概述

- 硬件 --> 内核 --> shell命令解释器 --> 外层应用程序
- Bourne Again（Bash）zsh也属于这个家族
- POSIX Shell（psh）

### 脚本的执行

1. echo命令
   1. echo 选项 输出内容
      1. -n 取消输出后的换行
      2. -e 支持转义字符
         1. 具体的转义表 google
         2. echo -e "\e[1;31m abcd \e[0m"
2. 脚本的开头要写出所用的shell
   1. #!/bin/bash
3. 绝对路径执行或相对路径
   1. 或者 bash hello.sh



### Bash的基本功能

1. 历史命令

   1. history
   2. 每次退出之后写在了家目录下。bash_history
   3. -c 清空 不建议使用 这个对于查错很有用 一般只有暴露密码的情况下才清空 比如mysql密码明文保存了
   4. -w 把缓存中的卸乳历史命令保存文件
   5. 历史文件条数存在/etc/profile
      1. 默认1000条
      2. 这个是放在硬盘而不是内存 可以多调点
   6. ！！执行上一条命令
   7. 其他的不常用 想看可以查

2. source命令

   1. . 就是source命令
   2. 作用是不用重新登陆 就让更新的配置文件生效
      1. source ~/.Bashrc
      2. . ~/.Bashrc

3. 命令执行的优先级

   1. 用绝对路径或相对路径执行的命令
   2. 别名
   3. Bash内部命令
   4. 按照$PATH环境变量定义的目录查找顺序找到的第一个命令

4. Bash常用快捷键

   1. ctrl+A 移动到行首
   2. ctrl+E 移动到行尾
   3. ctrl+C
   4. ctrl+L
   5. ctrl+U 删除或剪切光标之前的命令
   6. ctrl+K 删除或剪切光标之后的命令
   7. ctrl+Y 粘贴
   8. ctrl+R 在历史命令中搜索
   9. ctrl+D 退出当前终端 或者 发送
   10. ctrl+Z 暂停
   11. ctrl+S 暂停屏幕输出
   12. ctrl+Q 恢复屏幕输出

5. 输入输出重定向

   1. Bash的标准输入输出

   2. | 设备   | 设备文件名  | 文件描述符 | 类型         |
      | ------ | ----------- | ---------- | ------------ |
      | 键盘   | /dev/stdin  | 0          | 标准输入     |
      | 显示器 | /dev/stdout | 1          | 标准输出     |
      | 显示器 | /dev/stderr | 2          | 标准错误输出 |

      输出重定向

      | 类型                           | 符号                      | 作用                                                   |
      | ------------------------------ | ------------------------- | ------------------------------------------------------ |
      | 标准输出重定向                 | 命令 > 文件               | 以覆盖的方式，把命令的正确输出输出到指定的文件或设备中 |
      |                                | 命令 >> 文件              | 以追加的方式...                                        |
      | 标准错误输出重定向             | 错误命令 2>文件           | 以覆盖的方式，把命令的错误输出输出到指定的文件或设备中 |
      |                                | 错误命令 2>>文件          | 以追加的方式...                                        |
      | **正确输出和错误输出同时保存** | 命令 > 文件 2>&1          | 以覆盖的方式，把正确和错误输出都保存到同一个文件中     |
      |                                | **命令 > 文件 2>&1**      | 以追加的方式...                                        |
      |                                | 命令 &> 文件              | 以覆盖的方式，把正确和错误输出都保存到同一个文件中     |
      |                                | **命令 &>>文件**          | 以追加的方式...                                        |
      |                                | **命令>>文件1  2>>文件2** | 把正确的输出追加到文件1中，把错误的输出追加到文件2中   |
      |                                |                           |                                                        |

   3. 输入重定向

      1. wc 选项 文件名
         1. -c 统计字节数
         2. -w 统计单词数
         3. -l 统计行数
      2. wc < abc
      3. wc << uio
         1. 然后开始输入 知道碰到下一个uio终止

   4. 多命令执行顺序

   - ls && echo yes || echo no

   - 后面两个部分不能颠倒，因为如果ls报错了 第二条命令会执行 那么第三条命令也会执行了

     | 多命令执符 | 格式                 | 作用                                                         |
     | ---------- | -------------------- | ------------------------------------------------------------ |
     | ;          | 命令1 ; 命令2        | 多个命令顺序执行，之间没有任何逻辑关系联系                   |
     | &&         | **命令1 && 命令2**   | 当命令1正确执行（$?=0），则命令2才执行，当命令1执行不正确（$?≠0），则命令2不会执行 |
     | \|\|       | **命令1 \|\| 命令2** | 当命令1执行不正确（$?≠0)，命令2才执行，当命令1执行正确）（$?=0），命令2不会执行 |

   5. 管道符
      1. 行命令提取命令 grep
         1. -A n 列出后续的n行
         2. -B n 列出前面的n行

   6. Bash中的其他符号

      | 符号 | 作用                                                         |
      | ---- | ------------------------------------------------------------ |
      | ''   | 单引号内所有符号丧失功能 变成普通字符串                      |
      | ""   | 双引号中的特殊符号都没有特殊含义，但是"$" "`" "\" 是例外，拥有调用变量值 引用命令和转义符的特殊含义 |
      | ``   | 反引号内是系统命令 Bash会先执行它 例如 a = date 只会把date字符赋值给a 而a=`date` 会把命令执行的结果赋值给a |
      | $()  | 和反引号作用一样 用来引用系统命令 推荐用这个 反引号和单引号容易看混 用这个提高可读性 |
      | ()   | 用于一串命令执行时，()中的命令会在子Shell中运行 子Shell中的命令 不会影响父Shell的变量 name=sc （name=lm）这时候父shell的name还是sc |
      | {}   | 用于一串命令执行时，{}中的命令会在当前Shell执行，也可以用于变量变形与替换 大括号的最后一个命令必须用分号 第一个命令和左括号之间必须有一个空格 |
      | []   | 用于变量测试 后面单独写                                      |
      | #    | 注释                                                         |
      | $    | 用于调用变量                                                 |
      | \    | 转义符 将特殊符号转换成普通符号                              |
      |      |                                                              |

### 变量和运算符

1. 什么是变量
   1. 变量的默认类型都是字符串型，如果要进行数值运算，则必须制定变量类型为数值型
   2. 变量用等号连接值，等号左右两侧不能有空格
   3. 变量的值如果有空格，需要使用单引号或者双引号包括，如test=“hello world”
   4. 可以进行变量值的叠加，不过变量需要用双引号包含"$变量名" 或用 ${变量名}  
      例如：test="$test"456  
      test=${test}456
2. 变量的分类
   1. 用户自定义变量：自定义变量名和变量的值
   2. 环境变量：这种变量中主要保存的是和系统操作环境相关的数据，比如当前登陆用户，用户的家目录，命令的提示符等。
      1. 用户自定义环境变量
      2. 系统自带环境变量
         1. 命令和作用是固定的 内容可以自定义 比如umask的值 history储存的条数
         2. 防止混淆 环境变量全部大写！！！
      3. 位置参数变量
         1. 这种变量主要是用来向脚本传递参数或者数据的
         2. 名称作用确定 内容可以自定义
         3. 比较少 要背
      4. 预定义变量
         1. 同样也是只能改内容
         2. 比较少 要背

### 自定义变量

1. 调用记得加$ 定义的时候不需要加
2. 查看 
   1. set 选项
      1. -u 设定此选项，调用未声明变量时会报错（默认无任何提示）常见选项！！
      2. -x 设定此选项，在民营执行之前，会把命令先输出一次 不大用
      3. 如果什么选项都不加 就会查看所有的变量
      4. 但是有一部分环境变量看不到 需要用env看(注意 env也看不全 他俩互补)
3. 删除
   1. unset 变量名
      1. 注意不需要加$



### 环境变量

1. 环境变量在全部的shell中都生效 而用户自定义变量只在当前shell生效
2. 声明
   1. export AGE="18"
   2. 也可以先AGE="18" 再export AGE
3. 查看
   1. set 看不到一部分环境变量
   2. env 看不到一部分环境变量 和 全部的自定义变量
4. 删除
   1. usnet AGE
5. 改
   1. 就是覆盖

### 系统自带的环境变量

1. PATH变量：系统查找命令的路径
   1. 各个路径用:分隔 我们可以在后面添加其他的目录 放置自定的命令
2. PS1变量：命令提示符设置
   1. 具体改可以查文档
   2. 就是shell中命令行左边的显示的东西
3. LANG语系变量
   1. 查询
      1.  locale -a 看可以支持的语言
   2. LANG="en_US. UTF-8"

### 位置参数变量

| 位置参数变量 | 作用                                                         |
| ------------ | ------------------------------------------------------------ |
| $n           | 命令后第n个变量 $0是命令本身 10以上需要大括号 ${10} 缺点是没有提示 一般非作者根本不知道 命令后面应该输入什么  一般是用来写函数的 |
| $*           | 这个变量代表命令行中的所有参数，不过$*把所有的参数看成一个整体 |
| $@           | 这个变量也代表命令行中的所有参数，不过$@把每个参数区分对待   |
| $#           | 这个变量代表命令行中的所有参数的个数                         |
|              |                                                              |

- vi para.sh

- ```bash
  #!/bin/bash
  
  for i in "$*"
  	do
  		echo i
  	done
  	
  echo "===================="
  
  for j in "$@"
  	do
  		echo j
  	done
  ```

- ./para.sh 11 22 33 44

- ```bash
  11 22 33 44
  =========================
  11
  22
  33
  44
  ```



### 预定义变量

- 其实位置参数变量也是预定义变量 只是很常用

  | 预定义变量 | 作用                                                         |
  | ---------- | ------------------------------------------------------------ |
  | $?         | 最后一次执行命令的返回状态，如果这个变量的值为0，证明上一个证明正确执行；如果这个变量值为非0（具体哪个数由命令自己决定），则证明上一个命令执行不正确 |
  | $$         | 当前进程的ID号 PID                                           |
  | $!         | 后台运行的最后一个进程的PID                                  |
  |            |                                                              |

### 接收键盘输入

- **read 选项 变量名**

- -t 秒数：等待时间

- -p “提示信息”：等待输入时输出的提示信息

- -n 字符数：read命令只接受指定的字符数，就会执行

- -s：隐藏输入数据，适用于机密信息的输入

- ```bash
  #!/bin/bash
  
  read -t 30 -p "Please type in a number: " num1
  read -t 30 -p "Please type in another number: " num2
  
  sum=$(( $num1 + $num2 ))
  
  echo $sum
  
  ```



### Shell的运算符

1. 使用declare声明变量类型

   1. declare [+/-] 选项 变量名

      - declare -i $cc=$aa+$bb

      1. -：给变量设定类型属性
      2. +：取消变量的类型属性
      3. -a：声明为数组
         1. 其实数组直接用就行 因为格式比较特别
         2. name[0]="RenZhiheng"
         3. echo name[0]
      4. -i：声明为整数型
      5. -r：只读 一旦设置 既不能修改也不能删除 重启后失效
      6. -x：声明为环境变量
      7. -p：显示指定变量的被声明的类型

2. 数值运算方法

   1. declare法 不推荐 繁琐
   2. expr或let数值运算命令 不好用 expr命令里运算符两遍必须加空格 let稍微好点
   3. **$((运算式))**或者$[运算式] 推荐前者 因为[]还有测试的作用

   - ```bash
     #!/bin/bash
     
     read -t 30 -p "Num1 is: " num1
     read -t 30 -p "Num2 is: " num2
     read -n 1 -t 30 -p "The operator is[+-*/]: " oper
     
     ["$oper" == "+"] && echo "$(( $num1 + $num2 ))" && exit
     ["$oper" == "-"] && echo "$(( $num1 - $num2 ))" && exit
     ["$oper" == "*"] && echo "$(( $num1 * $num2 ))" && exit
     ["$oper" == "/"] && echo "$(( $num1 / $num2 ))" && exit
     
     echo "Incorrect input"
     
     
     #缺点很明显 没有判断num1和num2的输入是否正确 输错没有报错
     ```

     

3. 变量的测试与内容置换

   <table>
   <thead>
   <tr>
   <th>变量置换方式</th>
   <th>变量y没有设置</th>
   <th>变量y为空值</th>
   <th>变量y设置值</th>
   </tr>
   </thead>
   <tbody>
   <tr>
   <td>x=${y-新值}</td>
   <td>x=新值</td>
   <td>x为空</td>
   <td>x=$y</td>
   </tr>
   <tr>
   <td>x=${y:-新值}</td>
   <td>x=新值</td>
   <td>x=新值</td>
   <td>x=$y</td>
   </tr>
   <tr>
   <td>x=${y+新值}</td>
   <td>x为空</td>
   <td>x=新值</td>
   <td>x=新值</td>
   </tr>
   <tr>
   <td>x=${y:+新值}</td>
   <td>x为空</td>
   <td>x为空</td>
   <td>x=新值</td>
   </tr>
   <tr>
   <td>x=${y=新值}</td>
   <td>x=新值 y=新值</td>
   <td>x为空 y值不变</td>
   <td>x=$y y值不变</td>
   </tr>
   <tr>
   <td>x=${y:=新值}</td>
   <td>x=新值 y=新值</td>
   <td>x=新值 y=新值</td>
   <td>x=$y y值不变</td>
   </tr>
   <tr>
   <td>x=${y?新值}</td>
   <td>新值输出到标准错误输出（就是屏幕）</td>
   <td>x为空</td>
   <td>x=$y</td>
   </tr>
   <tr>
   <td>x=${y:?新值}</td>
   <td>新值输出到标准错误输出</td>
   <td>新值输出到标准错误输出</td>
   <td>x=$y</td>
   </tr>
   </tbody>
   </table>



### 环境变量配置文件

1. source命令  让环境变量配置文件直接生效

   1. source 配置文件
   2. . 配置文件

2. 环境变量配置文件

   1. 登陆时生效的环境变量配置文件有以下五个：

      - /etc/profile
      - /etc/profile.d/*.sh
      - ~/.bash_profile
      - ~/.bashrc
      - /etc/bashrc

      其中etc下的对所有用户生效

   2. 环境变量配置文件的调用过程

      ![环境变量配置文件调用过程](/Users/wenchaoli/Desktop/Images/环境变量配置文件调用过程.png)

   3. {其中的具体内容 包括两条调用路线：登陆与非登陆(sudo)}(https://www.bilibili.com/video/BV1ut411a7ro?p=126)

   4. 

